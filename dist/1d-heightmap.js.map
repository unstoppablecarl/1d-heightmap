{
  "version": 3,
  "sources": [
    "node_modules/browser-pack/_prelude.js",
    "node_modules/easing-utils/lib/easing.js",
    "src/1d-heightmap.js",
    "src/generators.js",
    "src/index.js",
    "src/interpolators.js",
    "src/key-indexes/index.js",
    "src/math.js",
    "src/methods/init.js",
    "src/methods/iterators.js",
    "src/methods/mergers.js",
    "src/methods/transformations.js",
    "src/renderer.js",
    "src/rng.js",
    "src/util.js"
  ],
  "names": [],
  "mappings": "AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9TA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACldA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1SA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "file": "generated.js",
  "sourceRoot": "",
  "sourcesContent": [
    "(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})",
    "\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.linear = linear;\nexports.easeInSine = easeInSine;\nexports.easeOutSine = easeOutSine;\nexports.easeInOutSine = easeInOutSine;\nexports.easeInQuad = easeInQuad;\nexports.easeOutQuad = easeOutQuad;\nexports.easeInOutQuad = easeInOutQuad;\nexports.easeInCubic = easeInCubic;\nexports.easeOutCubic = easeOutCubic;\nexports.easeInOutCubic = easeInOutCubic;\nexports.easeInQuart = easeInQuart;\nexports.easeOutQuart = easeOutQuart;\nexports.easeInOutQuart = easeInOutQuart;\nexports.easeInQuint = easeInQuint;\nexports.easeOutQuint = easeOutQuint;\nexports.easeInOutQuint = easeInOutQuint;\nexports.easeInExpo = easeInExpo;\nexports.easeOutExpo = easeOutExpo;\nexports.easeInOutExpo = easeInOutExpo;\nexports.easeInCirc = easeInCirc;\nexports.easeOutCirc = easeOutCirc;\nexports.easeInOutCirc = easeInOutCirc;\nexports.easeInBack = easeInBack;\nexports.easeOutBack = easeOutBack;\nexports.easeInOutBack = easeInOutBack;\nexports.easeInElastic = easeInElastic;\nexports.easeOutElastic = easeOutElastic;\nexports.easeInOutElastic = easeInOutElastic;\nexports.easeOutBounce = easeOutBounce;\nexports.easeInBounce = easeInBounce;\nexports.easeInOutBounce = easeInOutBounce;\n// Based on https://gist.github.com/gre/1650294\n\n// No easing, no acceleration\nfunction linear(t) {\n    return t;\n}\n\n// Slight acceleration from zero to full speed\nfunction easeInSine(t) {\n    return -1 * Math.cos(t * (Math.PI / 2)) + 1;\n}\n\n// Slight deceleration at the end\nfunction easeOutSine(t) {\n    return Math.sin(t * (Math.PI / 2));\n}\n\n// Slight acceleration at beginning and slight deceleration at end\nfunction easeInOutSine(t) {\n    return -0.5 * (Math.cos(Math.PI * t) - 1);\n}\n\n// Accelerating from zero velocity\nfunction easeInQuad(t) {\n    return t * t;\n}\n\n// Decelerating to zero velocity\nfunction easeOutQuad(t) {\n    return t * (2 - t);\n}\n\n// Acceleration until halfway, then deceleration\nfunction easeInOutQuad(t) {\n    return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;\n}\n\n// Accelerating from zero velocity\nfunction easeInCubic(t) {\n    return t * t * t;\n}\n\n// Decelerating to zero velocity\nfunction easeOutCubic(t) {\n    var t1 = t - 1;\n    return t1 * t1 * t1 + 1;\n}\n\n// Acceleration until halfway, then deceleration\nfunction easeInOutCubic(t) {\n    return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;\n}\n\n// Accelerating from zero velocity\nfunction easeInQuart(t) {\n    return t * t * t * t;\n}\n\n// Decelerating to zero velocity\nfunction easeOutQuart(t) {\n    var t1 = t - 1;\n    return 1 - t1 * t1 * t1 * t1;\n}\n\n// Acceleration until halfway, then deceleration\nfunction easeInOutQuart(t) {\n    var t1 = t - 1;\n    return t < 0.5 ? 8 * t * t * t * t : 1 - 8 * t1 * t1 * t1 * t1;\n}\n\n// Accelerating from zero velocity\nfunction easeInQuint(t) {\n    return t * t * t * t * t;\n}\n\n// Decelerating to zero velocity\nfunction easeOutQuint(t) {\n    var t1 = t - 1;\n    return 1 + t1 * t1 * t1 * t1 * t1;\n}\n\n// Acceleration until halfway, then deceleration\nfunction easeInOutQuint(t) {\n    var t1 = t - 1;\n    return t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * t1 * t1 * t1 * t1 * t1;\n}\n\n// Accelerate exponentially until finish\nfunction easeInExpo(t) {\n\n    if (t === 0) {\n        return 0;\n    }\n\n    return Math.pow(2, 10 * (t - 1));\n}\n\n// Initial exponential acceleration slowing to stop\nfunction easeOutExpo(t) {\n\n    if (t === 1) {\n        return 1;\n    }\n\n    return -Math.pow(2, -10 * t) + 1;\n}\n\n// Exponential acceleration and deceleration\nfunction easeInOutExpo(t) {\n\n    if (t === 0 || t === 1) {\n        return t;\n    }\n\n    var scaledTime = t * 2;\n    var scaledTime1 = scaledTime - 1;\n\n    if (scaledTime < 1) {\n        return 0.5 * Math.pow(2, 10 * scaledTime1);\n    }\n\n    return 0.5 * (-Math.pow(2, -10 * scaledTime1) + 2);\n}\n\n// Increasing velocity until stop\nfunction easeInCirc(t) {\n\n    var scaledTime = t / 1;\n    return -1 * (Math.sqrt(1 - scaledTime * t) - 1);\n}\n\n// Start fast, decreasing velocity until stop\nfunction easeOutCirc(t) {\n\n    var t1 = t - 1;\n    return Math.sqrt(1 - t1 * t1);\n}\n\n// Fast increase in velocity, fast decrease in velocity\nfunction easeInOutCirc(t) {\n\n    var scaledTime = t * 2;\n    var scaledTime1 = scaledTime - 2;\n\n    if (scaledTime < 1) {\n        return -0.5 * (Math.sqrt(1 - scaledTime * scaledTime) - 1);\n    }\n\n    return 0.5 * (Math.sqrt(1 - scaledTime1 * scaledTime1) + 1);\n}\n\n// Slow movement backwards then fast snap to finish\nfunction easeInBack(t) {\n    var magnitude = arguments.length <= 1 || arguments[1] === undefined ? 1.70158 : arguments[1];\n\n\n    var scaledTime = t / 1;\n    return scaledTime * scaledTime * ((magnitude + 1) * scaledTime - magnitude);\n}\n\n// Fast snap to backwards point then slow resolve to finish\nfunction easeOutBack(t) {\n    var magnitude = arguments.length <= 1 || arguments[1] === undefined ? 1.70158 : arguments[1];\n\n\n    var scaledTime = t / 1 - 1;\n\n    return scaledTime * scaledTime * ((magnitude + 1) * scaledTime + magnitude) + 1;\n}\n\n// Slow movement backwards, fast snap to past finish, slow resolve to finish\nfunction easeInOutBack(t) {\n    var magnitude = arguments.length <= 1 || arguments[1] === undefined ? 1.70158 : arguments[1];\n\n\n    var scaledTime = t * 2;\n    var scaledTime2 = scaledTime - 2;\n\n    var s = magnitude * 1.525;\n\n    if (scaledTime < 1) {\n\n        return 0.5 * scaledTime * scaledTime * ((s + 1) * scaledTime - s);\n    }\n\n    return 0.5 * (scaledTime2 * scaledTime2 * ((s + 1) * scaledTime2 + s) + 2);\n}\n// Bounces slowly then quickly to finish\nfunction easeInElastic(t) {\n    var magnitude = arguments.length <= 1 || arguments[1] === undefined ? 0.7 : arguments[1];\n\n\n    if (t === 0 || t === 1) {\n        return t;\n    }\n\n    var scaledTime = t / 1;\n    var scaledTime1 = scaledTime - 1;\n\n    var p = 1 - magnitude;\n    var s = p / (2 * Math.PI) * Math.asin(1);\n\n    return -(Math.pow(2, 10 * scaledTime1) * Math.sin((scaledTime1 - s) * (2 * Math.PI) / p));\n}\n\n// Fast acceleration, bounces to zero\nfunction easeOutElastic(t) {\n    var magnitude = arguments.length <= 1 || arguments[1] === undefined ? 0.7 : arguments[1];\n\n\n    var p = 1 - magnitude;\n    var scaledTime = t * 2;\n\n    if (t === 0 || t === 1) {\n        return t;\n    }\n\n    var s = p / (2 * Math.PI) * Math.asin(1);\n    return Math.pow(2, -10 * scaledTime) * Math.sin((scaledTime - s) * (2 * Math.PI) / p) + 1;\n}\n\n// Slow start and end, two bounces sandwich a fast motion\nfunction easeInOutElastic(t) {\n    var magnitude = arguments.length <= 1 || arguments[1] === undefined ? 0.65 : arguments[1];\n\n\n    var p = 1 - magnitude;\n\n    if (t === 0 || t === 1) {\n        return t;\n    }\n\n    var scaledTime = t * 2;\n    var scaledTime1 = scaledTime - 1;\n\n    var s = p / (2 * Math.PI) * Math.asin(1);\n\n    if (scaledTime < 1) {\n        return -0.5 * (Math.pow(2, 10 * scaledTime1) * Math.sin((scaledTime1 - s) * (2 * Math.PI) / p));\n    }\n\n    return Math.pow(2, -10 * scaledTime1) * Math.sin((scaledTime1 - s) * (2 * Math.PI) / p) * 0.5 + 1;\n}\n\n// Bounce to completion\nfunction easeOutBounce(t) {\n\n    var scaledTime = t / 1;\n\n    if (scaledTime < 1 / 2.75) {\n\n        return 7.5625 * scaledTime * scaledTime;\n    } else if (scaledTime < 2 / 2.75) {\n\n        var scaledTime2 = scaledTime - 1.5 / 2.75;\n        return 7.5625 * scaledTime2 * scaledTime2 + 0.75;\n    } else if (scaledTime < 2.5 / 2.75) {\n\n        var _scaledTime = scaledTime - 2.25 / 2.75;\n        return 7.5625 * _scaledTime * _scaledTime + 0.9375;\n    } else {\n\n        var _scaledTime2 = scaledTime - 2.625 / 2.75;\n        return 7.5625 * _scaledTime2 * _scaledTime2 + 0.984375;\n    }\n}\n\n// Bounce increasing in velocity until completion\nfunction easeInBounce(t) {\n    return 1 - easeOutBounce(1 - t);\n}\n\n// Bounce in and bounce out\nfunction easeInOutBounce(t) {\n\n    if (t < 0.5) {\n\n        return easeInBounce(t * 2) * 0.5;\n    }\n\n    return easeOutBounce(t * 2 - 1) * 0.5 + 0.5;\n}\n",
    "'use strict';\n\nvar factory = function OneDHeightmap(settings) {\n    return Object.create(factory.methods).init(settings);\n};\n\nfactory.methods = Object.assign(\n    {\n        factory: factory\n    },\n    require('./methods/mergers'),\n    require('./methods/init'),\n    require('./methods/iterators'),\n    require('./methods/transformations')\n);\n\nmodule.exports = factory;",
    "'use strict';\n\nvar arg                  = require('./util').arg;\nvar oneDHeightmapFactory = require('./1d-heightmap');\nvar rng                  = require('./rng');\nvar random               = rng.float;\nvar randomRange          = rng.range;\nvar randomRangeInt       = rng.rangeInt;\nvar randomSpacedIndexes  = rng.spacedIndexes;\n\nvar interpolate = require('./interpolators');\n\n\n\n\n\nvar generators = {\n\n    /**\n     * Create 1dHeightmap object with random data.\n     * @method random\n     * @param {Object} [settings] - Settings object.\n     * @param {Number} [settings.length] - Length of height map.\n     * @param {Array}  [settings.data] - Length of height map. If set, settings.length is ignored.\n     * @param {Number} [settings.min] - Min Height of height map.\n     * @param {Number} [settings.max] - Max Height of height map.\n     * @param {Number} [settings.startHeight] - Height of first value.\n     * @param {Number} [settings.endHeight] - Height of last value.\n     * @return {Object} Initialized 1dHeightmap object.\n     */\n    random: function(settings) {\n\n        var hm = oneDHeightmapFactory(settings);\n\n        var defaults = {\n            startHeight: undefined,\n            endHeight:   undefined,\n            min:         0,\n            max:         100,\n        };\n\n        var s = Object.assign({}, defaults, settings);\n\n        hm.mapEach(function(val, i) {\n            return randomRangeInt(s.min, s.max);\n        });\n\n        if (s.startHeight) {\n            hm.data[0] = s.startHeight;\n        }\n        if (s.endHeight) {\n            hm.data[hm.data.length - 1] = s.endHeight;\n        }\n        return hm;\n    },\n\n    /**\n    * Create 1dHeightmap object with random data.\n    * @method random\n    * @param {Object} [settings] - Settings object.\n    * @param {Number} [settings.length] - Length of height map.\n    * @param {Array}  [settings.data] - Length of height map. If set, settings.length is ignored.\n    * @param {Number} [settings.min] - Min Height of height map.\n    * @param {Number} [settings.max] - Max Height of height map.\n    * @param {Number} [settings.startHeight] - Height of first value.\n    * @param {Number} [settings.endHeight] - Height of last value.\n    * @param {Number} [settings.minSpacing] - Min distance between key positions initially created.\n    * @param {Number} [settings.maxSpacing] - Max distance between key positions initially created.\n    * @param {Function} [settings.interpolator] - Function to interpolate key position data.\n    * @return {Object} Initialized 1dHeightmap object.\n    */\n    perlin: function(settings) {\n\n        var hm       = oneDHeightmapFactory(settings);\n        var defaults = {\n            interpolator: interpolate.sin,\n        };\n\n        var s = Object.assign({}, defaults, settings);\n\n        var interpolator = s.interpolator;\n\n        var keyIndexes = this.keyIndexes(settings);\n        var results    = this.interpolateKeyIndexes(keyIndexes, interpolator);\n\n        hm.data = results;\n\n        return hm;\n    },\n\n\n    rough: function(settings) {\n        var hm = oneDHeightmapFactory(settings);\n\n        var defaults = {\n            // height that the height map will start at\n            startHeight: 1,\n            // height that the map will end at\n            endHeight: 1,\n\n            variance:          3,\n            edgeDeflectMargin: 0.25,\n            deviationChance:   0.6,\n            // distance at which the height starts tapering to the endHeight\n            endTaperMargin: undefined,\n\n            // distance at which the height starts tapering to the startHeight\n            startTaperMargin: undefined,\n            min:              0,\n            max:              100,\n            debug:            false,\n        };\n\n        var s   = Object.assign({}, defaults, settings);\n        var min = s.min;\n        var max = s.max;\n\n        var debug            = s.debug;\n        var startHeight      = arg(s.startHeight, min);\n        var startTaperMargin = arg(s.startTaperMargin, max * 0.25);\n        var startTaperHeight;\n        var startMinTaperHeight;\n\n        var endHeight      = arg(s.endHeight, min);\n        var endTaperMargin = arg(s.endTaperMargin, max * 0.25);\n        var endTaperHeight;\n        var endMinTaperHeight;\n\n        var length            = hm.data.length;\n        var prevHeight        = startHeight;\n        var edgeDeflectMargin = s.edgeDeflectMargin;\n        var variance          = s.variance;\n\n        if (debug) {\n            hm.debugData                 = hm.debugData || {};\n            hm.debugData.generateHill    = hm.debugData.generateHill || [];\n            hm.debugData.generateHill[0] = {\n                absoluteMin: startHeight,\n                absoluteMax: startHeight\n            }\n        }\n\n        hm.data[0] = startHeight;\n\n        var startSlope    = ((max - startHeight) / startTaperMargin);\n        var startMinSlope = (startHeight / startTaperMargin) * -1;\n        var endSlope      = ((max - endHeight) / endTaperMargin);\n        var endMinSlope   = (endHeight / endTaperMargin) * -1;\n\n        for (var i = 1; i < length; i++) {\n            var distanceFromEdge = false;\n            var startTaperRatio  = false;\n            var endTaperRatio    = false;\n            var minDeflectRatio  = false;\n            var maxDeflectRatio  = false;\n            var absoluteMin      = min;\n            var absoluteMax      = max;\n\n            if (i < startTaperMargin) {\n                distanceFromEdge = i;\n                startTaperRatio  = (i / startTaperMargin);\n                startTaperHeight = (startSlope * distanceFromEdge) + startHeight;\n                absoluteMax      = startTaperHeight;\n\n                startMinTaperHeight = (startMinSlope * distanceFromEdge) + startHeight;\n                absoluteMin         = startMinTaperHeight;\n            } else if (i > length - endTaperMargin) {\n                distanceFromEdge = length - i;\n                endTaperRatio    = ((length - i) / endTaperMargin);\n                endTaperHeight   = (endSlope * distanceFromEdge) + endHeight;\n                absoluteMax      = endTaperHeight;\n\n                endMinTaperHeight = (endMinSlope * distanceFromEdge) + endHeight;\n                absoluteMin       = endMinTaperHeight;\n            }\n\n            var lowVariance  = prevHeight - variance,\n                highVariance = prevHeight + variance;\n\n            if (lowVariance < absoluteMin) {\n                highVariance += absoluteMin - lowVariance;\n            }\n\n            var adjustedMin = Math.max(lowVariance, absoluteMin);\n            var adjustedMax = Math.min(highVariance, absoluteMax);\n            var height      = prevHeight;\n            var heightRatio = (height - absoluteMin) / (absoluteMax - absoluteMin);\n\n            // pull away from edges\n            if (heightRatio < edgeDeflectMargin) {\n                minDeflectRatio = 1 - (heightRatio * (1 / edgeDeflectMargin));\n            } else if (heightRatio > 1 - edgeDeflectMargin) {\n                maxDeflectRatio = ((heightRatio - edgeDeflectMargin) * (1 / edgeDeflectMargin));\n            }\n\n            // pull toward start/end height\n            if (\n                startTaperRatio !== false &&\n                height > absoluteMax &&\n                random() < startTaperRatio - 0.5\n            ) {\n                height = absoluteMax;\n            } else if (\n                endTaperRatio !== false &&\n                height > absoluteMax &&\n                random() < endTaperRatio - 0.5\n            ) {\n                height = absoluteMax;\n            }\n\n            // pull away from absoluteMin, percentOfMargin = (heightRatio * (1 /edgeMargin))\n            else if (\n                minDeflectRatio !== false &&\n                random() < minDeflectRatio\n            ) {\n                height += variance;\n            } else if (\n                maxDeflectRatio !== false &&\n                random() < maxDeflectRatio\n            ) {\n                height -= variance;\n            }\n            // random deviation\n            else if (random() < s.deviationChance) {\n                height = randomRangeInt(adjustedMin, adjustedMax);\n            }\n\n            hm.data[i] = height;\n\n            if (debug) {\n                hm.debugData.generateHill[i] = {\n                    adjustedMin: adjustedMin,\n                    adjustedMax: adjustedMax,\n                    absoluteMin: absoluteMin,\n                    absoluteMax: absoluteMax\n                };\n            }\n\n            prevHeight = hm.data[i];\n        }\n        if (s.endHeight) {\n            hm.data[hm.data.length - 1] = s.endHeight;\n        }\n\n        return hm;\n    },\n};\n\nObject.assign(generators, require('./key-indexes'));\nmodule.exports = generators;",
    "'use strict';\n\nvar api = {\n    create:      require('./1d-heightmap'),\n    generate:    require('./generators'),\n    draw:        require('./renderer'),\n    rng:         require('./rng'),\n    interpolate: require('./interpolators')\n};\n\nmodule.exports = api;",
    "'use strict';\n\nvar easing = require('easing-utils');\n\nvar block = function(k) {\n    return Math.round(k);\n};\n\nvar smoothStep = function(x) {\n    return x * x * (3 - 2 * x);\n};\n\nvar makeReversable = function(func1, func2) {\n    return function(a, b, x) {\n        if (a < b) {\n            return a + ((b - a) * func1(x));\n        } else {\n            return a + ((b - a) * func2(x));\n        }\n    };\n};\n\nvar make = function(func) {\n    return function(a, b, x) {\n        return a + ((b - a) * func(x));\n    };\n};\n\nvar e = easing;\n\nmodule.exports = {\n\n    linear: make(e.linear),\n\n    block:      make(block),\n    smoothStep: make(smoothStep),\n\n    sine:     make(e.easeInOutSine),\n    sineDown: makeReversable(e.easeInSine, e.easeOutSine),\n    sineUp:   makeReversable(e.easeOutSine, e.easeInSine),\n\n    quad:     make(e.easeInOutQuad),\n    quadUp:   makeReversable(e.easeOutQuad, e.easeInQuad),\n    quadDown: makeReversable(e.easeInQuad, e.easeOutQuad),\n\n    cubic:     make(e.easeInOutCubic),\n    cubicUp:   makeReversable(e.easeOutCubic, e.easeInCubic),\n    cubicDown: makeReversable(e.easeInCubic, e.easeOutCubic),\n\n    quart:     make(e.easeInOutQuart),\n    quartUp:   makeReversable(e.easeOutQuart, e.easeInQuart),\n    quartDown: makeReversable(e.easeInQuart, e.easeOutQuart),\n\n    quint:     make(e.easeInOutQuint),\n    quintUp:   makeReversable(e.easeOutQuint, e.easeInQuint),\n    quintDown: makeReversable(e.easeInQuint, e.easeOutQuint),\n\n    expo:     make(e.easeInOutExpo),\n    expoUp:   makeReversable(e.easeOutExpo, e.easeInExpo),\n    expoDown: makeReversable(e.easeInExpo, e.easeOutExpo),\n\n    circ:     make(e.easeInOutCirc),\n    circUp:   makeReversable(e.easeOutCirc, e.easeInCirc),\n    circDown: makeReversable(e.easeInCirc, e.easeOutCirc),\n\n};",
    "'use strict';\n\nvar arg                  = require('../util').arg;\nvar oneDHeightmapFactory = require('../1d-heightmap');\nvar rng                  = require('../rng');\nvar random               = rng.float;\nvar randomRange          = rng.range;\nvar randomRangeInt       = rng.rangeInt;\nvar randomSpacedIndexes  = rng.spacedIndexes;\n\nvar interpolators       = require('../interpolators');\nvar math                = require('../math');\nvar getDistance         = math.getDistance;\nvar getNormalizedVector = math.getNormalizedVector;\n\nmodule.exports = {\n    keyIndexes:                createKeyIndexes,\n    fromKeyIndexes:            fromKeyIndexes,\n    interpolateKeyIndexes:     interpolateKeyIndexes,\n    addKeyIndexes:             addKeyIndexes,\n    addDisplacementKeyIndexes: addDisplacementKeyIndexes,\n}\n\nfunction createKeyIndexes(settings) {\n    var defaults = {\n        length:      null,\n        startHeight: undefined,\n        endHeight:   undefined,\n\n        minSpacing:   undefined,\n        maxSpacing:   undefined,\n        interpolator: null,\n        min:          0,\n        max:          100,\n        minSlope:     undefined,\n        maxSlope:     undefined,\n    };\n\n    var s = Object.assign({}, defaults, settings);\n\n    var length      = s.length;\n    var startHeight = s.startHeight;\n    var endHeight   = s.endHeight;\n    var minSpacing  = arg(s.minSpacing, length * 0.1);\n    var maxSpacing  = arg(s.maxSpacing, length * 0.1);\n    var minHeight   = s.min;\n    var maxHeight   = s.max;\n    var minSlope    = s.minSlope;\n    var maxSlope    = s.maxSlope;\n\n    var keyIndexes = randomSpacedIndexes(length, minSpacing, maxSpacing);\n\n    var prev;\n\n    var out = keyIndexes.map(function(index, i, data) {\n        var value;\n\n        if (i === 0 && startHeight !== undefined) {\n            value = startHeight;\n        } else {\n            value = getValue(prev, index, minHeight, maxHeight, minSlope, maxSlope);\n        }\n\n        var result = {\n            index: index,\n            value: value,\n        };\n\n        prev = result;\n\n        return result;\n    });\n\n    if (endHeight !== undefined) {\n        out[out.length - 1].value = endHeight;\n    }\n\n    return out;\n}\n\nfunction getValue(prev, index, minHeight, maxHeight, minSlope, maxSlope) {\n    var min = minHeight;\n    var max = maxHeight;\n\n    if (prev !== undefined) {\n\n        var prevVal  = prev.value;\n        var distance = index - prev.index;\n\n        if (minSlope !== undefined) {\n            min = Math.max(min, prevVal + (distance * minSlope));\n        }\n\n        if (maxSlope !== undefined) {\n            max = Math.min(max, prevVal + (distance * maxSlope));\n        }\n    }\n\n    return randomRangeInt(min, max);\n}\n\nfunction interpolateKeyIndexes(keyIndexes, interpolator) {\n    var results = [];\n    interpolator = arg(interpolator, interpolators.linear);\n\n    keyIndexes.forEach(function(item, i) {\n\n        results.push(item.value);\n\n        var next = keyIndexes[i + 1];\n\n        if (!next) {\n            return;\n        }\n        var curerntKeyIndex = item.index;\n        var nextKeyIndex    = next.index;\n        var wavelength      = Math.abs(nextKeyIndex - curerntKeyIndex - 1);\n        var a               = item.value;\n        var b               = next.value;\n\n        for (var j = 0; j < wavelength; j++) {\n            var x               = j / wavelength;\n            var interpolatedVal = interpolator(a, b, x);\n            results.push(interpolatedVal);\n        }\n    });\n\n    return results;\n}\n\nfunction fromKeyIndexes(keyIndexes, interpolator) {\n    return oneDHeightmapFactory({\n        data: this.interpolateKeyIndexes(keyIndexes, interpolator)\n    });\n}\n\n\nfunction addKeyIndexes(settings) {\n    var defaults = {\n        keyIndexes: null,\n\n        // position on line determined by percent of distance between points\n        posRatioMin: 0.33,\n        posRatioMax: 0.66,\n\n        // distance from pos on line determined by percent of distance between points\n        distRatioMin: 0.1,\n        distRatioMax: 0.2,\n\n        // absolute min / max distance\n        distMin: undefined,\n        distMax: undefined,\n\n        direction:     undefined,\n        upDirection:   undefined,\n        downDirection: undefined,\n\n        upPosRatioMin:   undefined,\n        upPosRatioMax:   undefined,\n        downPosRatioMin: undefined,\n        downPosRatioMax: undefined,\n\n        upDistRatioMin:   undefined,\n        upDistRatioMax:   undefined,\n        downDistRatioMin: undefined,\n        downDistRatioMax: undefined,\n    };\n\n    var s = Object.assign({}, defaults, settings);\n\n    var keyIndexes = s.keyIndexes;\n\n    var result = [];\n\n    keyIndexes.forEach(function(item, i, data) {\n        var next = data[i + 1];\n\n        if (!next) {\n            result.push(item);\n            return;\n        }\n\n        var splitSettings = Object.assign({\n            left:  item,\n            right: next,\n        }, settings);\n\n        var add = splitKeyIndexes(splitSettings);\n\n        result.push(item);\n        result.push(add);\n\n    });\n\n    return result;\n\n}\n\nfunction splitKeyIndexes(settings) {\n    var defaults = {\n        left:  null,\n        right: null,\n\n        // position on line determined by percent of distance between points\n        posRatioMin: 0.33,\n        posRatioMax: 0.66,\n\n        // distance from pos on line determined by percent of distance between points\n        distRatioMin: 0.1,\n        distRatioMax: 0.2,\n\n        // absolute min / max distance\n        distMin: undefined,\n        distMax: undefined,\n\n        direction:     undefined,\n        upDirection:   undefined,\n        downDirection: undefined,\n\n        upPosRatioMin:   undefined,\n        upPosRatioMax:   undefined,\n        downPosRatioMin: undefined,\n        downPosRatioMax: undefined,\n\n        upDistRatioMin:   undefined,\n        upDistRatioMax:   undefined,\n        downDistRatioMin: undefined,\n        downDistRatioMax: undefined,\n    };\n\n    var s = Object.assign({}, defaults, settings);\n\n    var left  = s.left;\n    var right = s.right;\n\n    var slopeUp = left.value < right.value;\n\n    var posRatioMin  = s.posRatioMin;\n    var posRatioMax  = s.posRatioMax;\n    var distRatioMin = s.distRatioMin;\n    var distRatioMax = s.distRatioMax;\n    var direction    = s.direction;\n    var distMin      = s.distMin;\n    var distMax      = s.distMax;\n\n    if (slopeUp) {\n\n        posRatioMin  = arg(s.upPosRatioMin, posRatioMin);\n        posRatioMax  = arg(s.upPosRatioMax, posRatioMax);\n        distRatioMin = arg(s.upDistRatioMin, distRatioMin);\n        distRatioMax = arg(s.upDistRatioMax, distRatioMax);\n        direction    = arg(s.upDirection, direction);\n\n    } else {\n\n        posRatioMin  = arg(s.downPosRatioMin, posRatioMin);\n        posRatioMax  = arg(s.downPosRatioMax, posRatioMax);\n        distRatioMin = arg(s.downDistRatioMin, distRatioMin);\n        distRatioMax = arg(s.downDistRatioMax, distRatioMax);\n        direction    = arg(s.downDirection, direction);\n    }\n\n    direction = arg(direction, random() < 0.5 ? 'up' : 'down');\n\n    var posRatio  = randomRange(posRatioMin, posRatioMax);\n    var distRatio = randomRange(distRatioMin, distRatioMax);\n\n    var a = {\n        x: left.index,\n        y: left.value,\n    };\n\n    var b = {\n        x: right.index,\n        y: right.value,\n    };\n\n    var p = generateMidPoint(a, b, posRatio, distRatio, direction, distMin, distMax);\n\n    return {\n        value: p.y,\n        index: p.x\n    };\n}\n\nfunction generateMidPoint(a, b, cPosRatio, distRatio, direction, distMin, distMax) {\n    var vDist = getDistance(a, b);\n    var v     = getNormalizedVector(a, b, vDist);\n\n    var dx = b.x - a.x;\n    var dy = b.y - a.y;\n\n    // c is a point on line ab at given ratio\n    var c = {\n        x: (dx * cPosRatio),\n        y: (dy * cPosRatio)\n    };\n    // distance proportional to ab length\n    var dist = vDist * distRatio;\n\n    if (distMin !== undefined) {\n        dist = Math.max(distMin);\n    }\n    if (distMax !== undefined) {\n        dist = Math.min(distMax);\n    }\n\n    var vDir = vectorRotate90(v, direction);\n\n    var d = {\n        x: vDir.x * dist,\n        y: vDir.y * dist,\n    };\n\n    // width of line ab\n    var ab = dx;\n    // postion of d offset from c\n    var dC = c.x + d.x;\n    // scale to fit horizontal bounds of ab\n    var scale = false;\n\n    // d left of a\n    if (dC < 0) {\n        scale = -(c.x / d.x);\n    }\n    // d right of b\n    else if (dC > ab) {\n        scale = (dx - c.x) / (d.x);\n    }\n\n    if (scale !== false) {\n        d.x *= scale;\n        d.y *= scale;\n    }\n\n    // add offsets to d\n    d.x += c.x + a.x;\n    d.y += c.y + a.y;\n\n    d.x = Math.round(d.x);\n\n    if (d.x === a.x) {\n        d.x += 1;\n    }\n\n    if (d.x === b.x) {\n        d.x -= 1;\n    }\n\n    // set c offset for debug\n    // c.x += a.x;\n    // c.y += a.y;\n\n    return d;\n}\n\nfunction vectorRotate90(v, direction){\n    if (direction === 'left' || direction === 'up') {\n        return {\n            x: -v.y,\n            y: v.x,\n        }\n    }\n    else if (direction === 'right' || direction === 'down') {\n        return {\n            x: v.y,\n            y: -v.x,\n        }\n    }\n}\n\nfunction addDisplacementKeyIndexes(settings) {\n    var defaults = {\n        keyIndexes:           null,\n        startingDisplacement: 50,\n        roughness:            0.77,\n        maxIterations:        1,\n        calcDisplacement:     defaultCalcDisplacement,\n    };\n\n    var s = Object.assign({}, defaults, settings);\n\n    var keyIndexes           = s.keyIndexes;\n    var roughness            = s.roughness;\n    var maxIterations        = s.maxIterations;\n    var calcDisplacement     = s.calcDisplacement;\n    var startingDisplacement = s.startingDisplacement;\n\n    keyIndexes = keyIndexes.map(function(item) {\n        return Object.assign({}, item);\n    });\n\n    var results = [];\n\n    keyIndexes.forEach(function(item, i, data) {\n        var next = data[i + 1];\n        if (!next) {\n            results.push(item);\n            return;\n        }\n\n        var arr = split(item, next, startingDisplacement);\n        results = results.concat(item, arr);\n    });\n\n    return results;\n\n    function defaultCalcDisplacement(current, left, right, iteration) {\n        if (iteration == 1) {\n            return current;\n        }\n        return current * roughness;\n    }\n\n    function split(left, right, displacement, iteration) {\n        iteration = iteration || 0;\n        iteration++;\n\n        if (left.index + 1 == right.index) {\n            return false;\n        }\n\n        displacement = calcDisplacement(displacement, left, right, iteration);\n\n        var mid = splitNodes(left, right, displacement);\n\n        if (iteration >= maxIterations) {\n            return mid;\n        }\n\n        var result = [];\n\n        var canSplitLeft  = left.index + 1 !== mid.index;\n        var canSplitRight = right.index - 1 !== mid.index;\n\n        if (canSplitLeft) {\n\n            var leftSplit = split(left, mid, displacement, iteration);\n\n            if (leftSplit) {\n                result = result.concat(leftSplit);\n            }\n        }\n\n        result.push(mid);\n\n        if (canSplitRight) {\n\n            var rightSplit = split(mid, right, displacement, iteration);\n            if (rightSplit) {\n                result = result.concat(rightSplit);\n            }\n        }\n        return result;\n    }\n}\n\nfunction splitNodes(left, right, displacement) {\n    var midIndex   = Math.floor((left.index + right.index) * 0.5);\n    var midValue   = (left.value + right.value) * 0.5;\n    var adjustment = (randomRange(-1, 1) * displacement);\n\n    return {\n        index: midIndex,\n        value: midValue + adjustment,\n    };\n}",
    "'use strict';\n\n\nmodule.exports = {\n    getDistance: getDistance,\n    getNormalizedVector: getNormalizedVector,\n    isAbove: isAbove,\n};\n\nfunction getDistance(a, b) {\n\n    var dx = b.x - a.x\n    var dy = b.y - a.y\n\n    return Math.sqrt(dx * dx + dy * dy);\n}\n\nfunction getNormalizedVector(a, b, distance) {\n    distance = distance || getDistance(a, b);\n\n    var dx = b.x - a.x\n    var dy = b.y - a.y\n\n    return {\n        x: dx / distance,\n        y: dy / distance,\n    };\n}\n\nfunction isAbove(x1, y1, x2, y2, x, y) {\n\n    var dx = x2 - x1;\n    var dy = y2 - y1;\n\n    // cross product\n    var d = (x - x1) * dy - (y - y1) * dx;\n\n    return d < 0;\n}\n",
    "'use strict';\n\nvar makeArray = require('../util').makeArray;\n\nvar methods = {\n    /**\n     * Initialzie 1dHeightmap object.\n     * @method init\n     * @param {Object} [settings] - Settings object.\n     * @param {Number} [settings.length] - Length of height map.\n     * @param {Array}  [settings.data] - Length of height map. If set, settings.length is ignored.\n     * @return {Object} Initialized 1dHeightmap object.\n     */\n    init: function(settings) {\n        var s = settings || {};\n\n        this.data = s.data || makeArray(s.length);\n\n        return this;\n    },\n    copy: function() {\n        var settings = {\n            data: [].concat(this.data)\n        };\n        return this.factory(settings);\n    },\n    min: function() {\n        return Math.min.apply(null, this.data);\n    },\n    max: function() {\n        return Math.max.apply(null, this.data);\n    },\n    range: function() {\n        return this.max() - this.min();\n    }\n};\n\nmodule.exports = methods;\n",
    "'use strict';\n\nvar arg = require('../util').arg;\n\nvar methods = {\n    each: function(func, context) {\n        context = arg(context, this);\n\n        this.data.forEach(func, context);\n        return this;\n    },\n    map: function(func, context) {\n        return this.factory({\n            data: this.data.map(func, context)\n        });\n    },\n    mapEach: function(func, context) {\n        context = arg(context, this);\n\n        this.data = this.data.map(func, context);\n        return this;\n    },\n\n};\nmodule.exports = methods;\n",
    "'use strict';\n\nvar arg = require('../util').arg;\n\nvar methods = {\n\n    merge: function(heightmap, func, maxLength, defaultValue) {\n        maxLength    = arg(maxLength, Math.max(this.data.length, heightmap.data.length));\n        defaultValue = arg(defaultValue, 0);\n\n        var target = this,\n            source = heightmap,\n            i;\n        for (i = 0; i < maxLength; i++) {\n            var targetVal = target.data[i];\n            var srcVal    = source.data[i];\n\n            if (targetVal === undefined || targetVal === null) {\n                targetVal = defaultValue;\n            }\n\n            if (srcVal === undefined || srcVal === null) {\n                srcVal = defaultValue;\n            }\n\n            target.data[i] = func(targetVal, srcVal, i, target.data, source.data);\n        }\n        return this;\n    },\n\n    /**\n     * merge 2 height maps taking the lowest value per coord\n     * @method mergeMin\n     * @param {1dHeightMap} heightmap\n     * @return {1dHeightMap}\n     */\n    mergeMin: function(heightmap, maxLength, defaultValue) {\n        return this.merge(heightmap, function(a, b) {\n            return Math.min(a, b);\n        }, maxLength, defaultValue);\n    },\n\n    /**\n     * merge 2 height maps taking the highest value per coord\n     * @method mergeMax\n     * @param {1dHeightMap} heightmap\n     * @return {1dHeightMap}\n     */\n    mergeMax: function(heightmap, maxLength, defaultValue) {\n        return this.merge(heightmap, function(a, b) {\n            return Math.max(a, b);\n        }, maxLength, defaultValue);\n    },\n    mergeAdd: function(heightmap, maxLength, defaultValue) {\n        return this.merge(heightmap, function(a, b) {\n            return a + b;\n        }, maxLength, defaultValue);\n    },\n    mergeSubtract: function(heightmap, maxLength, defaultValue) {\n        return this.merge(heightmap, function(a, b) {\n            return a - b;\n        }, maxLength, defaultValue);\n    },\n    mergeMultiply: function(heightmap, maxLength, defaultValue) {\n        return this.merge(heightmap, function(a, b) {\n            return a * b;\n        }, maxLength, defaultValue);\n    },\n    mergeDivide: function(heightmap, maxLength, defaultValue) {\n        return this.merge(heightmap, function(a, b) {\n            return a / b;\n        }, maxLength, defaultValue);\n    },\n    mergeAverage: function(heightmap, maxLength, defaultValue) {\n        return this.merge(heightmap, function(a, b) {\n            return (a + b) / 2;\n        }, maxLength, defaultValue);\n    },\n    mergeAverageWeight: function(heightmap, weight, maxLength, defaultValue) {\n        weight = arg(weight, 1);\n        return this.merge(heightmap, function(a, b) {\n            return (a*weight + b) / (1 + weight);\n        }, maxLength, defaultValue);\n    },\n    mergeToScale: function(heightmap, maxLength, defaultValue) {\n        var max = this.max();\n        return this.merge(heightmap, function(a, b) {\n            var heightRatio = a / max;\n            return heightRatio * b;\n        }, maxLength, defaultValue);\n    },\n};\nmodule.exports = methods;",
    "'use strict';\nvar util = require('../util');\n\nvar arg                = util.arg;\nvar makeArray          = util.makeArray;\nvar sliceRelativeRange = util.sliceRelativeRange;\nvar arrayChunk         = util.arrayChunk;\n\nvar rng                 = require('../rng');\nvar random              = rng.float;\nvar randomRangeInt         = rng.rangeInt;\nvar randomSpacedIndexes = rng.spacedIndexes;\nvar randomMinMaxRangeValue    = rng.minMaxRangeValue;\n\nvar methods = {\n    /* adjustments */\n    adjustRandomSpacedPositions: function(minSpacing, maxSpacing, includeFirstAndLast, func) {\n        var indexes = randomSpacedIndexes(this.data.length, minSpacing, maxSpacing, includeFirstAndLast);\n        indexes.forEach(function(i) {\n            this.data[i] = func(this.data[i], i, this.data);\n        }, this);\n        return this;\n    },\n    adjustEvery: function(interval, func) {\n        return this.mapEach(function(val, i, arr) {\n            if (i % interval === 0) {\n                return func(val, i, arr);\n            } else {\n                return val;\n            }\n        });\n    },\n    adjustBetween: function(startIndex, endIndex, func) {\n        var data = this.data;\n        for (var i = startIndex; i <= endIndex; i++) {\n            data[i] = func(data[i], i, data);\n        }\n        return this;\n    },\n\n    adjustWithPrevNext: function(func) {\n        var data = this.data;\n\n        for (var i = 1; i < data.length - 1; i++) {\n            var prev    = data[i - 1];\n            var current = data[i];\n            var next    = data[i + 1];\n            data[i] = func(prev, current, next, i, data);\n        }\n        return this;\n    },\n\n    clamp: function(minValue, maxValue) {\n        return this.mapEach(function(val) {\n            val = Math.min(val, maxValue);\n            return Math.max(val, minValue);\n        })\n    },\n    clampMax: function(maxValue) {\n        return this.mapEach(function(val) {\n            return Math.min(val, maxValue);\n        })\n    },\n    clampMin: function(minValue) {\n        return this.mapEach(function(val) {\n            return Math.max(val, minValue);\n        })\n    },\n\n    trimHeight: function(){\n        var min = this.min();\n        return this.subtract(min);\n    },\n    add: function(val) {\n        return this.mapEach(function(v) {\n            return v + val;\n        });\n    },\n    subtract: function(val) {\n        return this.mapEach(function(v) {\n            return v - val;\n        });\n    },\n    multiply: function(val) {\n        return this.mapEach(function(v) {\n            return v * val;\n        });\n    },\n    divide: function(val) {\n        return this.mapEach(function(v) {\n            return v / val;\n        });\n    },\n    scale: function(scale) {\n        return this.multiply(scale);\n    },\n    invert: function() {\n        return this.mapEach(function(val) {\n            return this.max() - val;\n        });\n    },\n    reverse: function() {\n        this.data.reverse();\n        return this;\n    },\n    scaleHeightTo: function(maxHeight) {\n        var ratio = maxHeight / this.max();\n        return this.multiply(ratio);\n    },\n    scaleLengthTo: function(newLenght, interpolateFunc) {\n        var data      = this.data;\n        var percent   = (newLenght - 1) / (data.length - 1);\n        var keyPoints = [];\n\n        var prevIndex;\n        data.forEach(function(val, index) {\n\n            var newIndex = Math.ceil(index * percent)\n\n            if (newIndex == prevIndex) {\n                return;\n            }\n            keyPoints.push({\n                index: newIndex,\n                value: val\n            });\n\n            prevIndex = newIndex;\n        });\n        var results = [];\n        keyPoints.forEach(function(item, index) {\n\n            results.push(item.value);\n\n            if (index === keyPoints.length - 1) {\n                return;\n            }\n\n            var nextItem     = keyPoints[index + 1];\n            var currentIndex = item.index;\n            var nextIndex    = nextItem.index;\n            var chunk        = nextIndex - currentIndex - 1;\n            var a            = item.value;\n            var b            = nextItem.value;\n\n            for (var i = 0; i < chunk; i++) {\n                var x      = i / chunk;\n                var newVal = interpolateFunc(a, b, x);\n                results.push(newVal);\n            }\n        });\n\n        this.data = results;\n\n        return this;\n    },\n\n    smooth: function(weight) {\n        weight = arg(weight, 1);\n        var total = 2 + weight;\n\n        return this.adjustWithPrevNext(function(prev, current, next) {\n            current *= weight;\n            return (prev + current + next) / total;\n        });\n    },\n\n    smoothSlopes: function(weight) {\n        weight = arg(weight, 1);\n\n        var total = 2 + weight;\n\n        return this.adjustWithPrevNext(function(prev, current, next) {\n\n            if (\n                // slope up\n                (prev < current && current < next) ||\n                // slope down\n                (prev > current && current > next)\n            ) {\n                return (prev + current + next) / total;\n            }\n\n            return current;\n        });\n    },\n\n    smoothCorners: function() {\n\n        return this.adjustWithPrevNext(function(prev, current, next) {\n            var prevR    = Math.round(prev);\n            var currentR = Math.round(current);\n            var nextR    = Math.round(next);\n\n            if (\n                (prevR != nextR) &&\n                (currentR == prevR || currentR == nextR)\n            ) {\n                return (prev + next) / 2;\n            }\n\n            return current;\n        });\n    },\n\n    /** RNG transforms */\n    weightedRatioAdjustment: function(height, variance, ratioWeight, func) {\n        height      = arg(height, this.max() * 0.1);\n        ratioWeight = arg(ratioWeight, 1);\n        variance    = arg(variance, 0.33);\n\n        return this.mapEach(function(height, i, data) {\n            var ratio          = (height / this.max()) * ratioWeight;\n            var randomVariance = random() * variance;\n            var percent        = (randomVariance + ratio) / (1 + ratioWeight);\n            var adjustment     = percent * height;\n            return func(height, adjustment);\n        });\n    },\n    shrink: function(shrinkHeight, variance, shrinkHeightRatioWeight) {\n        return this.weightedRatioAdjustment(\n            shrinkHeight,\n            variance,\n            shrinkHeightRatioWeight,\n            function(val, adjustment) {\n                return val - adjustment;\n            }\n        );\n    },\n    grow: function(growHeight, variance, growHeightRatioWeight) {\n        return this.weightedRatioAdjustment(\n            growHeight,\n            variance,\n            growHeightRatioWeight,\n            function(val, adjustment) {\n                return val + adjustment;\n            }\n        );\n    },\n    drip: function(minLength, maxLength, chance) {\n        minLength = arg(minLength, this.max() * 0.25);\n        maxLength = arg(maxLength, this.max() * 0.75);\n        chance    = arg(chance, 0.45);\n\n        return this.mapEach(function(val) {\n            if (random() < chance) {\n                var newVal = val + randomRangeInt(minLength, maxLength);\n                return newVal;\n            }\n            return val;\n        });\n    },\n    dripByHeight: function(frequency, percentVariance, frequencyHeightRatioWeight, percentVarianceHeightRatioWeight) {\n        percentVariance                  = arg(percentVariance, 1);\n        frequency                        = arg(frequency, 0.45);\n        frequencyHeightRatioWeight       = arg(frequencyHeightRatioWeight, 1);\n        percentVarianceHeightRatioWeight = arg(percentVarianceHeightRatioWeight, 1);\n\n        return this.mapEach(function(val) {\n            var heightRatio = val / this.max();\n            var finalChance = (frequency + heightRatio * frequencyHeightRatioWeight) / 1 + frequencyHeightRatioWeight;\n\n            if (random() < finalChance) {\n                var varianceTotal = 1 + percentVarianceHeightRatioWeight,\n                    finalVariance = (percentVariance + heightRatio * percentVarianceHeightRatioWeight) / varianceTotal;\n\n                var newVal = val + random() * (this.max() * finalVariance);\n                return newVal;\n            }\n            return val;\n        });\n    },\n\n    /**\n     * Smooth with random adjustment\n     * @method smoothDistort\n     * @param {Number} range - number of indexes before and after each index to take into account.\n     * @param {Number} weight - weight of each index value when averaging with min / max\n     * @return {[type]}\n     */\n    distort: function(range, weight) {\n        range  = arg(range, 1);\n        weight = arg(weight, 1);\n\n        this.mapEach(function(val, i, data) {\n            var values = arrayChunk(data, i - range, i + range);\n            return randomMinMaxRangeValue(values, val, weight);\n        });\n        return this;\n    },\n    distortChunk: function(startIndex, endIndex, weight) {\n        var values = arrayChunk(this.data, startIndex, endIndex);\n\n        return this.adjustBetween(startIndex, endIndex, function(val, i, data){\n            return randomMinMaxRangeValue(values, val, weight);\n        });\n    },\n};\nmodule.exports = methods;",
    "'use strict';\n\nfunction draw(settings) {\n    var defaults = {\n        heightmap:   null,\n        ctx:         null,\n        x:           0,\n        y:           0,\n        direction:   'up',\n        scale:       1,\n        columnWidth: 1,\n        color:       'rgb(50,100,150)',\n        debug:       false,\n    };\n\n    var s = Object.assign(defaults, settings)\n\n    var heightmap   = s.heightmap;\n    var ctx         = s.ctx;\n    var rx          = s.x;\n    var ry          = s.y;\n    var direction   = s.direction;\n    var scale       = s.scale;\n    var columnWidth = s.columnWidth;\n    var color       = s.color;\n    var debug       = s.debug;\n\n    var data = heightmap.data,\n        len  = data.length,\n        height,\n        i,\n        x,\n        y,\n        w,\n        h;\n\n    for (i = 0; i < len; i++) {\n\n        height        = Math.round(data[i]);\n        ctx.fillStyle = color;\n        if (direction === 'up') {\n            x = rx + i * columnWidth;\n            y = ry - height;\n            w = columnWidth;\n            h = height;\n        } else if (direction === 'left') {\n            x = rx - height;\n            y = ry + i * columnWidth;\n            w = height;\n            h = columnWidth;\n        } else if (direction === 'right') {\n            x = rx;\n            y = ry + i * columnWidth;\n            w = height;\n            h = columnWidth;\n        } else if (direction === 'down') {\n            x = rx + i * columnWidth;\n            y = ry;\n            w = columnWidth;\n            h = height;\n        }\n        ctx.fillRect(\n            Math.round(x * scale),\n            Math.round(y * scale),\n            Math.round(w * scale),\n            Math.round(h * scale)\n        );\n\n        if (\n            debug &&\n            heightmap.debugData &&\n            heightmap.debugData.generateHill\n        ) {\n            var debugData = heightmap.debugData.generateHill;\n\n            var absoluteMin = debugData[i].absoluteMin;\n            var absoluteMax = debugData[i].absoluteMax;\n            var adjustedMin = debugData[i].adjustedMin;\n            var adjustedMax = debugData[i].adjustedMax;\n\n            var debugAbsoluteMinColor = 'red';\n            var debugAbsoluteMaxColor = 'red';\n            var debugAdjustedMinColor = 'orange';\n            var debugAdjustedMaxColor = 'orange';\n\n            var dx = x;\n            var dy = y;\n\n            if (direction === 'up') {\n                dy = ry;\n\n            } else if (direction === 'left') {\n                dx = rx;\n            } else if (direction === 'right') {\n                dx = rx;\n\n            } else if (direction === 'down') {\n                dy = ry;\n            }\n\n            debugDraw(heightmap, ctx, dx, dy, direction, scale, absoluteMin, debugAbsoluteMinColor);\n            debugDraw(heightmap, ctx, dx, dy, direction, scale, absoluteMax, debugAbsoluteMaxColor);\n            debugDraw(heightmap, ctx, dx, dy, direction, scale, adjustedMin, debugAdjustedMinColor);\n            debugDraw(heightmap, ctx, dx, dy, direction, scale, adjustedMax, debugAdjustedMaxColor);\n        }\n    }\n    return this;\n}\n\nfunction debugDraw(heightmap, ctx, x, y, direction, scale, val, color) {\n\n    var dx = x,\n        dy = y;\n\n    if (direction === 'up') {\n        dy = y - val;\n    } else if (direction === 'left') {\n        dx = x + heightmap.max() - val;\n\n    } else if (direction === 'right') {\n        dx = x + val;\n\n    } else if (direction === 'down') {\n        dy = y + val;\n    }\n\n    ctx.globalAlpha = 1;\n    ctx.fillStyle   = color;\n    ctx.fillRect(\n        dx * scale,\n        dy * scale,\n        1 * scale,\n        1 * scale\n    );\n}\n\nmodule.exports = draw;",
    "'use strict';\n\nvar util               = require('./util');\nvar arg                = util.arg;\nvar arrayFilterIndexes = util.arrayFilterIndexes;\nvar arraySum           = util.arraySum;\n\nvar rng = Math.random;\n\nfunction randomBool(){\n    return rng() > 0.5;\n}\n\nfunction arrayMin(arr) {\n    return Math.min.apply(null, arr);\n}\n\nfunction arrayMax(arr) {\n    return Math.max.apply(null, arr);\n}\n\nfunction randomFloat() {\n    return rng();\n}\n\nfunction randomRangeInt(min, max) {\n    return Math.floor(rng() * (max - min + 1)) + min;\n}\n\nfunction randomRangeFloat(min, max) {\n    return rng() * (max - min) + min;\n}\n\nfunction minMaxRangeValue(array, value, weight) {\n    weight = arg(weight, 1);\n    value *= weight;\n\n    var minVal = arrayMin(array);\n    var maxVal = arrayMax(array);\n\n    var min = (minVal + value) / (1 + weight);\n    var max = (maxVal + value) / (1 + weight);\n\n    return randomRangeInt(min, max);\n}\n\nfunction randomArrayIndex(arr) {\n    return randomRangeInt(0, arr.length - 1);\n}\n\nfunction randomArrayValue(arr) {\n    return arr[randomArrayIndex(arr)];\n}\n\nfunction randomArrayIndexValue(arr, func) {\n\n    var index = randomArrayIndex(arr);\n    return {\n        index: index,\n        value: arr[index]\n    };\n}\n\nfunction randomFilteredArrayIndex(arr, func) {\n    var validIndexes = arrayFilterIndexes(arr, func);\n    if (!validIndexes.length) {\n        return false;\n    }\n    return randomArrayValue(validIndexes);\n}\n\nfunction randomFilteredArrayValue(arr, func) {\n    var filtered = arr.filter(func);\n    if (!filtered.length) {\n        return false;\n    }\n    return randomArrayValue(filtered);\n}\n\nfunction randomFilteredArrayIndexValue(arr, func) {\n\n    var filtered = [];\n\n    arr.forEach(function(val, i, data) {\n        if (func(val, i, data)) {\n            filtered.push({\n                index: i,\n                value: val,\n            });\n        }\n    });\n\n    return randomArrayValue(filtered);\n}\n\nfunction randomSpacedIndexes(length, minSpacing, maxSpacing) {\n    var min = Math.round(minSpacing);\n    var max = Math.round(maxSpacing);\n\n    var chunkSizes = getChunkSizes(length, min, max);\n    var sum        = arraySum(chunkSizes);\n\n    if (sum < length || hasInvalidChunkSizes(chunkSizes, min, max)) {\n        chunkSizes = distribute(chunkSizes, min, max, length);\n    }\n\n    var d       = 0;\n    var indexes = chunkSizes.map(function(val) {\n        d += val;\n        return d - 1;\n    });\n\n    indexes = [0].concat(indexes);\n\n    return indexes;\n\n    function hasInvalidChunkSizes(arr, min, max) {\n        for (var i = 0; i < arr.length; i++) {\n            var val = arr[i];\n            if (val < min || val > max) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function getChunkSizes(length, min, max) {\n\n        var remaining = length;\n        var chunks    = [];\n\n        while (remaining > 0) {\n            var chunkSize = randomRangeInt(min, max);\n            chunkSize = Math.min(remaining, chunkSize);\n\n            remaining -= chunkSize;\n            chunks.push(chunkSize);\n        }\n\n        return chunks;\n    }\n\n    function distributeFromValid(arr, min, max, length) {\n        // start with remaining\n        var newIndex = length - arraySum(arr);\n\n        while (arraySum(arr) + newIndex < length) {\n\n            var validIndex = randomFilteredArrayIndex(arr, function(val) {\n                return val > min\n            });\n\n            if (validIndex === false) {\n                break;\n            }\n\n            arr[validIndex]--;\n            newIndex++;\n        }\n        // add new index\n        arr.push(newIndex);\n        return arr;\n    }\n\n    function distributeToValid(arr, min, max, length) {\n\n        while (arraySum(arr) < length) {\n            var validIndex = randomFilteredArrayIndex(arr, function(val) {\n                return val < max;\n            });\n\n            if (validIndex === false) {\n                break;\n            }\n            arr[validIndex]++;\n        }\n\n        return arr;\n    }\n\n    function distribute(arr, min, max, length) {\n        var availableToRemove = 0;\n        var availableToAdd    = 0;\n\n        // remove invalid\n        arr = arr.filter(function(val) {\n            return val >= min;\n        });\n\n        arr.forEach(function(val, i, data) {\n            availableToRemove += val - min;\n            availableToAdd += max - val;\n        });\n        var sum = arraySum(arr);\n\n        var needToAdd              = length - sum;\n        var canDistributeFromValid = availableToRemove >= needToAdd;\n        var canDistributeToValid   = availableToAdd >= needToAdd;\n\n        var options = [];\n\n        if (canDistributeFromValid) {\n            options.push(distributeFromValid);\n        }\n        if (canDistributeToValid) {\n            options.push(distributeToValid);\n        }\n\n        if (!options.length) {\n            return arr;\n        }\n\n        var func = randomArrayValue(options);\n        return func(arr, min, max, length);\n\n    }\n\n}\n\nvar methods = {\n    set: function(newRng) {\n        rng = newRng;\n    },\n    bool:       randomBool,\n    float:      randomFloat,\n    range:      randomRangeFloat,\n    rangeFloat: randomRangeFloat,\n    rangeInt:   randomRangeInt,\n\n    spacedIndexes:    randomSpacedIndexes,\n    minMaxRangeValue: minMaxRangeValue,\n\n    arrayIndex:      randomArrayIndex,\n    arrayValue:      randomArrayValue,\n    arrayIndexValue: randomArrayIndexValue,\n\n    filteredArrayIndex:      randomFilteredArrayIndex,\n    filteredArrayValue:      randomFilteredArrayValue,\n    filteredArrayIndexValue: randomFilteredArrayIndexValue,\n\n};\n\nmodule.exports = methods;",
    "'use strict';\n\nvar arg = function(val, defaultVal) {\n    return val !== undefined ? val : defaultVal;\n};\n\nmodule.exports = {\n    arg: arg,\n\n    makeArray: function(length, value) {\n        value = arg(value, 0);\n        var a = [];\n\n        for (var i = 0; i < length; i++) {\n            a[i] = value;\n        }\n        return a;\n    },\n\n    /**\n     * Slice array values within given range relative to i\n     * @method sliceRelativeRange\n     * @param {Array} array\n     * @param {Number} i - index\n     * @param {Number} range - number of array values to include before and after i\n     * @return {Array}\n     */\n    sliceRelativeRange: function(array, i, range) {\n        var minI = Math.max(i - range, 0);\n        var maxI = i + range + 1;\n        return array.slice(minI, maxI);\n    },\n    arrayChunk: function(array, startIndex, endIndex) {\n        var minI = Math.max(startIndex, 0);\n        var maxI = endIndex + 1;\n        return array.slice(minI, maxI);\n    },\n    arrayFilterIndexes: function(arr, func) {\n        var out = [];\n        arr.forEach(function(val, i) {\n            if (func(val, i, arr)) {\n                out.push(i);\n            }\n        });\n        return out;\n    },\n    arraySum: function(arr, defaultVal) {\n        defaultVal = arg(defaultVal, 0);\n        return arr.reduce(function(prev, current){\n            return prev + current\n        }, defaultVal);\n    }\n\n};"
  ]
}