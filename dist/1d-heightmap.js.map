{
  "version": 3,
  "sources": [
    "node_modules/browser-pack/_prelude.js",
    "node_modules/easing-utils/lib/easing.js",
    "src/1d-heightmap.js",
    "src/generators.js",
    "src/index.js",
    "src/interpolators.js",
    "src/methods/init.js",
    "src/methods/iterators.js",
    "src/methods/mergers.js",
    "src/methods/transformations.js",
    "src/renderer.js",
    "src/rng.js",
    "src/util.js"
  ],
  "names": [],
  "mappings": "AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9TA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7OA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "file": "generated.js",
  "sourceRoot": "",
  "sourcesContent": [
    "(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})",
    "\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.linear = linear;\nexports.easeInSine = easeInSine;\nexports.easeOutSine = easeOutSine;\nexports.easeInOutSine = easeInOutSine;\nexports.easeInQuad = easeInQuad;\nexports.easeOutQuad = easeOutQuad;\nexports.easeInOutQuad = easeInOutQuad;\nexports.easeInCubic = easeInCubic;\nexports.easeOutCubic = easeOutCubic;\nexports.easeInOutCubic = easeInOutCubic;\nexports.easeInQuart = easeInQuart;\nexports.easeOutQuart = easeOutQuart;\nexports.easeInOutQuart = easeInOutQuart;\nexports.easeInQuint = easeInQuint;\nexports.easeOutQuint = easeOutQuint;\nexports.easeInOutQuint = easeInOutQuint;\nexports.easeInExpo = easeInExpo;\nexports.easeOutExpo = easeOutExpo;\nexports.easeInOutExpo = easeInOutExpo;\nexports.easeInCirc = easeInCirc;\nexports.easeOutCirc = easeOutCirc;\nexports.easeInOutCirc = easeInOutCirc;\nexports.easeInBack = easeInBack;\nexports.easeOutBack = easeOutBack;\nexports.easeInOutBack = easeInOutBack;\nexports.easeInElastic = easeInElastic;\nexports.easeOutElastic = easeOutElastic;\nexports.easeInOutElastic = easeInOutElastic;\nexports.easeOutBounce = easeOutBounce;\nexports.easeInBounce = easeInBounce;\nexports.easeInOutBounce = easeInOutBounce;\n// Based on https://gist.github.com/gre/1650294\n\n// No easing, no acceleration\nfunction linear(t) {\n    return t;\n}\n\n// Slight acceleration from zero to full speed\nfunction easeInSine(t) {\n    return -1 * Math.cos(t * (Math.PI / 2)) + 1;\n}\n\n// Slight deceleration at the end\nfunction easeOutSine(t) {\n    return Math.sin(t * (Math.PI / 2));\n}\n\n// Slight acceleration at beginning and slight deceleration at end\nfunction easeInOutSine(t) {\n    return -0.5 * (Math.cos(Math.PI * t) - 1);\n}\n\n// Accelerating from zero velocity\nfunction easeInQuad(t) {\n    return t * t;\n}\n\n// Decelerating to zero velocity\nfunction easeOutQuad(t) {\n    return t * (2 - t);\n}\n\n// Acceleration until halfway, then deceleration\nfunction easeInOutQuad(t) {\n    return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;\n}\n\n// Accelerating from zero velocity\nfunction easeInCubic(t) {\n    return t * t * t;\n}\n\n// Decelerating to zero velocity\nfunction easeOutCubic(t) {\n    var t1 = t - 1;\n    return t1 * t1 * t1 + 1;\n}\n\n// Acceleration until halfway, then deceleration\nfunction easeInOutCubic(t) {\n    return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;\n}\n\n// Accelerating from zero velocity\nfunction easeInQuart(t) {\n    return t * t * t * t;\n}\n\n// Decelerating to zero velocity\nfunction easeOutQuart(t) {\n    var t1 = t - 1;\n    return 1 - t1 * t1 * t1 * t1;\n}\n\n// Acceleration until halfway, then deceleration\nfunction easeInOutQuart(t) {\n    var t1 = t - 1;\n    return t < 0.5 ? 8 * t * t * t * t : 1 - 8 * t1 * t1 * t1 * t1;\n}\n\n// Accelerating from zero velocity\nfunction easeInQuint(t) {\n    return t * t * t * t * t;\n}\n\n// Decelerating to zero velocity\nfunction easeOutQuint(t) {\n    var t1 = t - 1;\n    return 1 + t1 * t1 * t1 * t1 * t1;\n}\n\n// Acceleration until halfway, then deceleration\nfunction easeInOutQuint(t) {\n    var t1 = t - 1;\n    return t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * t1 * t1 * t1 * t1 * t1;\n}\n\n// Accelerate exponentially until finish\nfunction easeInExpo(t) {\n\n    if (t === 0) {\n        return 0;\n    }\n\n    return Math.pow(2, 10 * (t - 1));\n}\n\n// Initial exponential acceleration slowing to stop\nfunction easeOutExpo(t) {\n\n    if (t === 1) {\n        return 1;\n    }\n\n    return -Math.pow(2, -10 * t) + 1;\n}\n\n// Exponential acceleration and deceleration\nfunction easeInOutExpo(t) {\n\n    if (t === 0 || t === 1) {\n        return t;\n    }\n\n    var scaledTime = t * 2;\n    var scaledTime1 = scaledTime - 1;\n\n    if (scaledTime < 1) {\n        return 0.5 * Math.pow(2, 10 * scaledTime1);\n    }\n\n    return 0.5 * (-Math.pow(2, -10 * scaledTime1) + 2);\n}\n\n// Increasing velocity until stop\nfunction easeInCirc(t) {\n\n    var scaledTime = t / 1;\n    return -1 * (Math.sqrt(1 - scaledTime * t) - 1);\n}\n\n// Start fast, decreasing velocity until stop\nfunction easeOutCirc(t) {\n\n    var t1 = t - 1;\n    return Math.sqrt(1 - t1 * t1);\n}\n\n// Fast increase in velocity, fast decrease in velocity\nfunction easeInOutCirc(t) {\n\n    var scaledTime = t * 2;\n    var scaledTime1 = scaledTime - 2;\n\n    if (scaledTime < 1) {\n        return -0.5 * (Math.sqrt(1 - scaledTime * scaledTime) - 1);\n    }\n\n    return 0.5 * (Math.sqrt(1 - scaledTime1 * scaledTime1) + 1);\n}\n\n// Slow movement backwards then fast snap to finish\nfunction easeInBack(t) {\n    var magnitude = arguments.length <= 1 || arguments[1] === undefined ? 1.70158 : arguments[1];\n\n\n    var scaledTime = t / 1;\n    return scaledTime * scaledTime * ((magnitude + 1) * scaledTime - magnitude);\n}\n\n// Fast snap to backwards point then slow resolve to finish\nfunction easeOutBack(t) {\n    var magnitude = arguments.length <= 1 || arguments[1] === undefined ? 1.70158 : arguments[1];\n\n\n    var scaledTime = t / 1 - 1;\n\n    return scaledTime * scaledTime * ((magnitude + 1) * scaledTime + magnitude) + 1;\n}\n\n// Slow movement backwards, fast snap to past finish, slow resolve to finish\nfunction easeInOutBack(t) {\n    var magnitude = arguments.length <= 1 || arguments[1] === undefined ? 1.70158 : arguments[1];\n\n\n    var scaledTime = t * 2;\n    var scaledTime2 = scaledTime - 2;\n\n    var s = magnitude * 1.525;\n\n    if (scaledTime < 1) {\n\n        return 0.5 * scaledTime * scaledTime * ((s + 1) * scaledTime - s);\n    }\n\n    return 0.5 * (scaledTime2 * scaledTime2 * ((s + 1) * scaledTime2 + s) + 2);\n}\n// Bounces slowly then quickly to finish\nfunction easeInElastic(t) {\n    var magnitude = arguments.length <= 1 || arguments[1] === undefined ? 0.7 : arguments[1];\n\n\n    if (t === 0 || t === 1) {\n        return t;\n    }\n\n    var scaledTime = t / 1;\n    var scaledTime1 = scaledTime - 1;\n\n    var p = 1 - magnitude;\n    var s = p / (2 * Math.PI) * Math.asin(1);\n\n    return -(Math.pow(2, 10 * scaledTime1) * Math.sin((scaledTime1 - s) * (2 * Math.PI) / p));\n}\n\n// Fast acceleration, bounces to zero\nfunction easeOutElastic(t) {\n    var magnitude = arguments.length <= 1 || arguments[1] === undefined ? 0.7 : arguments[1];\n\n\n    var p = 1 - magnitude;\n    var scaledTime = t * 2;\n\n    if (t === 0 || t === 1) {\n        return t;\n    }\n\n    var s = p / (2 * Math.PI) * Math.asin(1);\n    return Math.pow(2, -10 * scaledTime) * Math.sin((scaledTime - s) * (2 * Math.PI) / p) + 1;\n}\n\n// Slow start and end, two bounces sandwich a fast motion\nfunction easeInOutElastic(t) {\n    var magnitude = arguments.length <= 1 || arguments[1] === undefined ? 0.65 : arguments[1];\n\n\n    var p = 1 - magnitude;\n\n    if (t === 0 || t === 1) {\n        return t;\n    }\n\n    var scaledTime = t * 2;\n    var scaledTime1 = scaledTime - 1;\n\n    var s = p / (2 * Math.PI) * Math.asin(1);\n\n    if (scaledTime < 1) {\n        return -0.5 * (Math.pow(2, 10 * scaledTime1) * Math.sin((scaledTime1 - s) * (2 * Math.PI) / p));\n    }\n\n    return Math.pow(2, -10 * scaledTime1) * Math.sin((scaledTime1 - s) * (2 * Math.PI) / p) * 0.5 + 1;\n}\n\n// Bounce to completion\nfunction easeOutBounce(t) {\n\n    var scaledTime = t / 1;\n\n    if (scaledTime < 1 / 2.75) {\n\n        return 7.5625 * scaledTime * scaledTime;\n    } else if (scaledTime < 2 / 2.75) {\n\n        var scaledTime2 = scaledTime - 1.5 / 2.75;\n        return 7.5625 * scaledTime2 * scaledTime2 + 0.75;\n    } else if (scaledTime < 2.5 / 2.75) {\n\n        var _scaledTime = scaledTime - 2.25 / 2.75;\n        return 7.5625 * _scaledTime * _scaledTime + 0.9375;\n    } else {\n\n        var _scaledTime2 = scaledTime - 2.625 / 2.75;\n        return 7.5625 * _scaledTime2 * _scaledTime2 + 0.984375;\n    }\n}\n\n// Bounce increasing in velocity until completion\nfunction easeInBounce(t) {\n    return 1 - easeOutBounce(1 - t);\n}\n\n// Bounce in and bounce out\nfunction easeInOutBounce(t) {\n\n    if (t < 0.5) {\n\n        return easeInBounce(t * 2) * 0.5;\n    }\n\n    return easeOutBounce(t * 2 - 1) * 0.5 + 0.5;\n}\n",
    "'use strict';\n\nvar factory = function OneDHeightmap(settings) {\n    return Object.create(factory.methods).init(settings);\n};\n\nfactory.methods = Object.assign(\n    {\n        factory: factory\n},\n    require('./methods/mergers'),\n    require('./methods/init'),\n    require('./methods/iterators'),\n    require('./methods/transformations')\n);\n\nmodule.exports = factory;",
    "'use strict';\n\nvar arg                  = require('./util').arg;\nvar oneDHeightmapFactory = require('./1d-heightmap');\nvar rng                  = require('./rng');\nvar random               = rng.float;\nvar randomRange          = rng.range;\nvar randomSpacedIndexes  = rng.spacedIndexes;\n\nvar interpolate = require('./interpolators');\n\nvar generators = {\n\n    /**\n     * Create 1dHeightmap object with random data.\n     * @method random\n     * @param {Object} [settings] - Settings object.\n     * @param {Number} [settings.length] - Length of height map.\n     * @param {Array}  [settings.data] - Length of height map. If set, settings.length is ignored.\n     * @param {Number} [settings.min] - Min Height of height map.\n     * @param {Number} [settings.max] - Max Height of height map.\n     * @param {Number} [settings.startHeight] - Height of first value.\n     * @param {Number} [settings.endHeight] - Height of last value.\n     * @return {Object} Initialized 1dHeightmap object.\n     */\n    random: function(settings) {\n\n        var hm = oneDHeightmapFactory(settings);\n\n        var defaults = {\n            startHeight: undefined,\n            endHeight:   undefined,\n            min:         0,\n            max:         100,\n        };\n\n        var s = Object.assign({}, defaults, settings);\n\n        hm.mapEach(function(val, i) {\n            return randomRange(s.min, s.max);\n        });\n\n        if (s.startHeight) {\n            hm.data[0] = s.startHeight;\n        }\n        if (s.endHeight) {\n            hm.data[hm.data.length - 1] = s.endHeight;\n        }\n        return hm;\n    },\n\n    /**\n    * Create 1dHeightmap object with random data.\n    * @method random\n    * @param {Object} [settings] - Settings object.\n    * @param {Number} [settings.length] - Length of height map.\n    * @param {Array}  [settings.data] - Length of height map. If set, settings.length is ignored.\n    * @param {Number} [settings.min] - Min Height of height map.\n    * @param {Number} [settings.max] - Max Height of height map.\n    * @param {Number} [settings.startHeight] - Height of first value.\n    * @param {Number} [settings.endHeight] - Height of last value.\n    * @param {Number} [settings.minSpacing] - Min distance between key positions initially created.\n    * @param {Number} [settings.maxSpacing] - Max distance between key positions initially created.\n    * @param {Function} [settings.interpolator] - Function to interpolate key position data.\n    * @return {Object} Initialized 1dHeightmap object.\n    */\n    perlin: function(settings) {\n\n        var hm       = oneDHeightmapFactory(settings);\n        var defaults = {\n            interpolator: interpolate.sin,\n        };\n\n        var s = Object.assign({}, defaults, settings);\n\n        var interpolator = s.interpolator;\n\n        var keyIndexes = this.keyIndexes(settings);\n        var results    = this.interpolateKeyIndexes(keyIndexes, interpolator);\n\n        hm.data = results;\n\n        return hm;\n    },\n\n    keyIndexes: function(settings) {\n        var defaults = {\n            length:      null,\n            startHeight: undefined,\n            endHeight:   undefined,\n\n            minSpacing:   undefined,\n            maxSpacing:   undefined,\n            interpolator: null,\n            min:          0,\n            max:          100,\n            minSlope:    undefined,\n            maxSlope:    undefined,\n        };\n\n        var s = Object.assign({}, defaults, settings);\n\n        var length      = s.length;\n        var startHeight = s.startHeight;\n        var endHeight   = s.endHeight;\n        var minSpacing  = arg(s.minSpacing, length * 0.1);\n        var maxSpacing  = arg(s.maxSpacing, length * 0.1);\n        var minHeight   = s.min;\n        var maxHeight   = s.max;\n        var minSlope   = s.minSlope;\n        var maxSlope   = s.maxSlope;\n\n        var keyIndexes = randomSpacedIndexes(length, minSpacing, maxSpacing, true);\n\n        var getValue = function(prev) {\n            var min = minHeight;\n            var max = maxHeight;\n\n\n            if (prev !== undefined) {\n\n                var positive = random() < 0.5;\n\n                if (positive) {\n\n                    if (minSlope !== undefined) {\n                        min = Math.min(max, prev + minSlope);\n                    }\n\n                    if (maxSlope !== undefined) {\n                        max = Math.min(max, prev + maxSlope);\n                    }\n                } else {\n\n                    if (minSlope !== undefined) {\n                        min = Math.max(min, prev - maxSlope);\n                    }\n\n                    if (maxSlope !== undefined) {\n                        max = Math.max(min, prev - minSlope);\n                    }\n                }\n            }\n\n            return randomRange(min, max);\n        };\n\n        var prev;\n\n        var out = keyIndexes.map(function(index, i, data) {\n            var value;\n\n            if (i === 0 && startHeight !== undefined) {\n                value = startHeight;\n            } else {\n                value = getValue(prev);\n            }\n\n            prev = value;\n\n            return {\n                index: index,\n                value: value,\n            };\n        });\n\n        if (endHeight !== undefined) {\n            out[out.length - 1].value = endHeight;\n        }\n\n        return out;\n    },\n\n    interpolateKeyIndexes: function(keyIndexes, interpolator) {\n        var results = [];\n        keyIndexes.forEach(function(item, i) {\n\n            results.push(item.value);\n\n            var nextItem = keyIndexes[i + 1];\n\n            if (!nextItem) {\n                return;\n            }\n            var curerntKeyIndex = item.index;\n            var nextKeyIndex    = nextItem.index;\n            var wavelength      = Math.abs(nextKeyIndex - curerntKeyIndex - 1);\n            var a               = item.value;\n            var b               = nextItem.value;\n\n            for (var j = 0; j < wavelength; j++) {\n                var x               = j / wavelength;\n                var interpolatedVal = interpolator(a, b, x);\n                results.push(interpolatedVal);\n            }\n        });\n\n        return results;\n    },\n\n    rough: function(settings) {\n        var hm = oneDHeightmapFactory(settings);\n\n        var defaults = {\n            // height that the height map will start at\n            startHeight: 1,\n            // height that the map will end at\n            endHeight: 1,\n\n            variance:          3,\n            edgeDeflectMargin: 0.25,\n            deviationChance:   0.6,\n            // distance at which the height starts tapering to the endHeight\n            endTaperMargin: undefined,\n\n            // distance at which the height starts tapering to the startHeight\n            startTaperMargin: undefined,\n            min:              0,\n            max:              100,\n            debug:            false,\n        };\n\n        var s   = Object.assign({}, defaults, settings);\n        var min = s.min;\n        var max = s.max;\n\n        var debug            = s.debug;\n        var startHeight      = arg(s.startHeight, min);\n        var startTaperMargin = arg(s.startTaperMargin, max * 0.25);\n        var startTaperHeight;\n        var startMinTaperHeight;\n\n        var endHeight      = arg(s.endHeight, min);\n        var endTaperMargin = arg(s.endTaperMargin, max * 0.25);\n        var endTaperHeight;\n        var endMinTaperHeight;\n\n        var length            = hm.data.length;\n        var prevHeight        = startHeight;\n        var edgeDeflectMargin = s.edgeDeflectMargin;\n        var variance          = s.variance;\n\n        if (debug) {\n            hm.debugData                 = hm.debugData || {};\n            hm.debugData.generateHill    = hm.debugData.generateHill || [];\n            hm.debugData.generateHill[0] = {\n                absoluteMin: startHeight,\n                absoluteMax: startHeight\n            }\n        }\n\n        hm.data[0] = startHeight;\n\n        var startSlope    = ((max - startHeight) / startTaperMargin);\n        var startMinSlope = (startHeight / startTaperMargin) * -1;\n        var endSlope      = ((max - endHeight) / endTaperMargin);\n        var endMinSlope   = (endHeight / endTaperMargin) * -1;\n\n        for (var i = 1; i < length; i++) {\n            var distanceFromEdge = false;\n            var startTaperRatio  = false;\n            var endTaperRatio    = false;\n            var minDeflectRatio  = false;\n            var maxDeflectRatio  = false;\n            var absoluteMin      = min;\n            var absoluteMax      = max;\n\n            if (i < startTaperMargin) {\n                distanceFromEdge = i;\n                startTaperRatio  = (i / startTaperMargin);\n                startTaperHeight = (startSlope * distanceFromEdge) + startHeight;\n                absoluteMax      = startTaperHeight;\n\n                startMinTaperHeight = (startMinSlope * distanceFromEdge) + startHeight;\n                absoluteMin         = startMinTaperHeight;\n            } else if (i > length - endTaperMargin) {\n                distanceFromEdge = length - i;\n                endTaperRatio    = ((length - i) / endTaperMargin);\n                endTaperHeight   = (endSlope * distanceFromEdge) + endHeight;\n                absoluteMax      = endTaperHeight;\n\n                endMinTaperHeight = (endMinSlope * distanceFromEdge) + endHeight;\n                absoluteMin       = endMinTaperHeight;\n            }\n\n            var lowVariance  = prevHeight - variance,\n                highVariance = prevHeight + variance;\n\n            if (lowVariance < absoluteMin) {\n                highVariance += absoluteMin - lowVariance;\n            }\n\n            var adjustedMin = Math.max(lowVariance, absoluteMin);\n            var adjustedMax = Math.min(highVariance, absoluteMax);\n            var height      = prevHeight;\n            var heightRatio = (height - absoluteMin) / (absoluteMax - absoluteMin);\n\n            // pull away from edges\n            if (heightRatio < edgeDeflectMargin) {\n                minDeflectRatio = 1 - (heightRatio * (1 / edgeDeflectMargin));\n            } else if (heightRatio > 1 - edgeDeflectMargin) {\n                maxDeflectRatio = ((heightRatio - edgeDeflectMargin) * (1 / edgeDeflectMargin));\n            }\n\n            // pull toward start/end height\n            if (\n                startTaperRatio !== false &&\n                height > absoluteMax &&\n                random() < startTaperRatio - 0.5\n            ) {\n                height = absoluteMax;\n            } else if (\n                endTaperRatio !== false &&\n                height > absoluteMax &&\n                random() < endTaperRatio - 0.5\n            ) {\n                height = absoluteMax;\n            }\n\n            // pull away from absoluteMin, percentOfMargin = (heightRatio * (1 /edgeMargin))\n            else if (\n                minDeflectRatio !== false &&\n                random() < minDeflectRatio\n            ) {\n                height += variance;\n            } else if (\n                maxDeflectRatio !== false &&\n                random() < maxDeflectRatio\n            ) {\n                height -= variance;\n            }\n            // random deviation\n            else if (random() < s.deviationChance) {\n                height = randomRange(adjustedMin, adjustedMax);\n            }\n\n            hm.data[i] = height;\n\n            if (debug) {\n                hm.debugData.generateHill[i] = {\n                    adjustedMin: adjustedMin,\n                    adjustedMax: adjustedMax,\n                    absoluteMin: absoluteMin,\n                    absoluteMax: absoluteMax\n                };\n            }\n\n            prevHeight = hm.data[i];\n        }\n        if (s.endHeight) {\n            hm.data[hm.data.length - 1] = s.endHeight;\n        }\n\n        return hm;\n    },\n};\n\nmodule.exports = generators;",
    "'use strict';\n\nvar api = {\n    create:      require('./1d-heightmap'),\n    generate:    require('./generators'),\n    draw:        require('./renderer'),\n    rng:         require('./rng'),\n    interpolate: require('./interpolators')\n};\n\nmodule.exports = api;",
    "'use strict';\n\nvar easing = require('easing-utils');\n\nvar block = function(k) {\n    return Math.round(k);\n};\n\nvar smoothStep = function(x) {\n    return x * x * (3 - 2 * x);\n};\n\nvar makeReversable = function(func1, func2) {\n    return function(a, b, x) {\n        if (a < b) {\n            return a + ((b - a) * func1(x));\n        } else {\n            return a + ((b - a) * func2(x));\n        }\n    };\n};\n\nvar make = function(func) {\n    return function(a, b, x) {\n        return a + ((b - a) * func(x));\n    };\n};\n\nvar e = easing;\n\nmodule.exports = {\n\n    linear: make(e.linear),\n\n    block:      make(block),\n    smoothStep: make(smoothStep),\n\n    sine:     make(e.easeInOutSine),\n    sineDown: makeReversable(e.easeInSine, e.easeOutSine),\n    sineUp:   makeReversable(e.easeOutSine, e.easeInSine),\n\n    quad:     make(e.easeInOutQuad),\n    quadUp:   makeReversable(e.easeOutQuad, e.easeInQuad),\n    quadDown: makeReversable(e.easeInQuad, e.easeOutQuad),\n\n    cubic:     make(e.easeInOutCubic),\n    cubicUp:   makeReversable(e.easeOutCubic, e.easeInCubic),\n    cubicDown: makeReversable(e.easeInCubic, e.easeOutCubic),\n\n    quart:     make(e.easeInOutQuart),\n    quartUp:   makeReversable(e.easeOutQuart, e.easeInQuart),\n    quartDown: makeReversable(e.easeInQuart, e.easeOutQuart),\n\n    quint:     make(e.easeInOutQuint),\n    quintUp:   makeReversable(e.easeOutQuint, e.easeInQuint),\n    quintDown: makeReversable(e.easeInQuint, e.easeOutQuint),\n\n    expo:     make(e.easeInOutExpo),\n    expoUp:   makeReversable(e.easeOutExpo, e.easeInExpo),\n    expoDown: makeReversable(e.easeInExpo, e.easeOutExpo),\n\n    circ:     make(e.easeInOutCirc),\n    circUp:   makeReversable(e.easeOutCirc, e.easeInCirc),\n    circDown: makeReversable(e.easeInCirc, e.easeOutCirc),\n\n};",
    "'use strict';\n\nvar makeArray = require('../util').makeArray;\n\nvar methods = {\n    /**\n     * Initialzie 1dHeightmap object.\n     * @method init\n     * @param {Object} [settings] - Settings object.\n     * @param {Number} [settings.length] - Length of height map.\n     * @param {Array}  [settings.data] - Length of height map. If set, settings.length is ignored.\n     * @return {Object} Initialized 1dHeightmap object.\n     */\n    init: function(settings) {\n        var s = settings || {};\n\n        this.data = s.data || makeArray(s.length);\n\n        return this;\n    },\n    copy: function() {\n        var settings = {\n            data: [].concat(this.data)\n        };\n        return this.factory(settings);\n    },\n    min: function() {\n        return Math.min.apply(null, this.data);\n    },\n    max: function() {\n        return Math.max.apply(null, this.data);\n    },\n    range: function() {\n        return this.max() - this.min();\n    }\n};\n\nmodule.exports = methods;\n",
    "'use strict';\n\nvar arg = require('../util').arg;\n\nvar methods = {\n    each: function(func, context) {\n        context = arg(context, this);\n\n        this.data.forEach(func, context);\n        return this;\n    },\n    map: function(func, context) {\n        return this.copy({\n            data: this.data.map(func, context)\n        });\n    },\n    mapEach: function(func, context) {\n        context = arg(context, this);\n\n        this.data = this.data.map(func, context);\n        return this;\n    },\n\n\n};\nmodule.exports = methods;\n",
    "'use strict';\n\nvar arg = require('../util').arg;\n\nvar methods = {\n\n    merge: function(heightmap, func, maxLength, defaultValue) {\n        maxLength    = arg(maxLength, Math.max(this.data.length, heightmap.data.length));\n        defaultValue = arg(defaultValue, 0);\n\n        var target = this,\n            source = heightmap,\n            i;\n        for (i = 0; i < maxLength; i++) {\n            var targetVal = target.data[i];\n            var srcVal    = source.data[i];\n\n            if (targetVal === undefined || targetVal === null) {\n                targetVal = defaultValue;\n            }\n\n            if (srcVal === undefined || srcVal === null) {\n                srcVal = defaultValue;\n            }\n\n            target.data[i] = func(targetVal, srcVal, i, target.data, source.data);\n        }\n        return this;\n    },\n\n    /**\n     * merge 2 height maps taking the lowest value per coord\n     * @method mergeMin\n     * @param {1dHeightMap} heightmap\n     * @return {1dHeightMap}\n     */\n    mergeMin: function(heightmap, maxLength, defaultValue) {\n        return this.merge(heightmap, function(a, b) {\n            return Math.min(a, b);\n        }, maxLength, defaultValue);\n    },\n\n    /**\n     * merge 2 height maps taking the highest value per coord\n     * @method mergeMax\n     * @param {1dHeightMap} heightmap\n     * @return {1dHeightMap}\n     */\n    mergeMax: function(heightmap, maxLength, defaultValue) {\n        return this.merge(heightmap, function(a, b) {\n            return Math.max(a, b);\n        }, maxLength, defaultValue);\n    },\n    mergeAdd: function(heightmap, maxLength, defaultValue) {\n        return this.merge(heightmap, function(a, b) {\n            return a + b;\n        }, maxLength, defaultValue);\n    },\n    mergeSubtract: function(heightmap, maxLength, defaultValue) {\n        return this.merge(heightmap, function(a, b) {\n            return a - b;\n        }, maxLength, defaultValue);\n    },\n    mergeMultiply: function(heightmap, maxLength, defaultValue) {\n        return this.merge(heightmap, function(a, b) {\n            return a * b;\n        }, maxLength, defaultValue);\n    },\n    mergeDivide: function(heightmap, maxLength, defaultValue) {\n        return this.merge(heightmap, function(a, b) {\n            return a / b;\n        }, maxLength, defaultValue);\n    },\n    mergeAverage: function(heightmap, maxLength, defaultValue) {\n        return this.merge(heightmap, function(a, b) {\n            return (a + b) / 2;\n        }, maxLength, defaultValue);\n    },\n    mergeToScale: function(heightmap, maxLength, defaultValue) {\n        var max = this.max();\n        return this.merge(heightmap, function(a, b) {\n            var heightRatio = a / max;\n            return heightRatio * b;\n        }, maxLength, defaultValue);\n    },\n};\nmodule.exports = methods;",
    "'use strict';\nvar arg       = require('../util').arg;\nvar makeArray = require('../util').makeArray;\n\nvar rng                 = require('../rng');\nvar random              = rng.float;\nvar randomRange         = rng.range;\nvar randomSpacedIndexes = rng.spacedIndexes;\n\nvar methods = {\n    clamp: function(minValue, maxValue) {\n        return this.mapEach(function(val) {\n            val = Math.min(val, maxValue);\n            return Math.max(val, minValue);\n        })\n    },\n    clampMax: function(maxValue) {\n        return this.mapEach(function(val) {\n            return Math.min(val, maxValue);\n        })\n    },\n    clampMin: function(minValue) {\n        return this.mapEach(function(val) {\n            return Math.max(val, minValue);\n        })\n    },\n    add: function(val) {\n        return this.mapEach(function(v) {\n            return v + val;\n        });\n    },\n    subtract: function(val) {\n        return this.mapEach(function(v) {\n            return v - val;\n        });\n    },\n    multiply: function(val) {\n        return this.mapEach(function(v) {\n            return v * val;\n        });\n    },\n    divide: function(val) {\n        return this.mapEach(function(v) {\n            return v / val;\n        });\n    },\n    scale: function(scale) {\n        return this.multiply(scale);\n    },\n    invert: function() {\n        return this.mapEach(function(val) {\n            return this.max() - val;\n        });\n    },\n    reverse: function() {\n        this.data.reverse();\n        return this;\n    },\n    scaleToHeight: function(maxHeight) {\n        var ratio = maxHeight / this.max();\n        return this.multiply(ratio);\n    },\n    scaleLengthTo: function(newLenght, interpolateFunc) {\n        var data      = this.data;\n        var percent   = (newLenght - 1) / (data.length - 1);\n        var keyPoints = [];\n\n        var prevIndex;\n        data.forEach(function(val, index) {\n\n            var newIndex = Math.ceil(index * percent)\n\n            if (newIndex == prevIndex) {\n                return;\n            }\n            keyPoints.push({\n                index: newIndex,\n                value: val\n            });\n\n            prevIndex = newIndex;\n        });\n        var results = [];\n        keyPoints.forEach(function(item, index) {\n\n            results.push(item.value);\n\n            if (index === keyPoints.length - 1) {\n                return;\n            }\n\n            var nextItem     = keyPoints[index + 1];\n            var currentIndex = item.index;\n            var nextIndex    = nextItem.index;\n            var chunk        = nextIndex - currentIndex - 1;\n            var a            = item.value;\n            var b            = nextItem.value;\n\n            for (var i = 0; i < chunk; i++) {\n                var x      = i / chunk;\n                var newVal = interpolateFunc(a, b, x);\n                results.push(newVal);\n            }\n        });\n\n        this.data = results;\n\n        return this;\n    },\n\n    smooth: function(weight) {\n        weight = arg(weight, 1);\n\n        var data = this.data,\n            i,\n            prev = data[0];\n        for (i = 1; i < data.length - 1; i++) {\n            var current = data[i],\n                next    = data[i + 1],\n                total   = 2 + weight;\n            current = current * weight;\n            data[i] = (prev + current + next) / total;\n            prev    = current;\n        }\n        return this;\n    },\n    /** RNG transforms */\n    weightedRatioAdjustment: function(height, variance, ratioWeight, func) {\n        height      = arg(height, this.max() * 0.1);\n        ratioWeight = arg(ratioWeight, 1);\n        variance    = arg(variance, 0.33);\n\n        return this.mapEach(function(height, i, data) {\n            var ratio          = (height / this.max()) * ratioWeight;\n            var randomVariance = random() * variance;\n            var percent        = (randomVariance + ratio) / (1 + ratioWeight);\n            var adjustment     = (percent * height);\n            return func(height, adjustment);\n        });\n    },\n    shrink: function(shrinkHeight, variance, shrinkHeightRatioWeight) {\n        return this.weightedRatioAdjustment(\n            shrinkHeight,\n            variance,\n            shrinkHeightRatioWeight,\n            function(val, adjustment) {\n                return val - adjustment;\n            }\n        );\n    },\n    grow: function(growHeight, variance, growHeightRatioWeight) {\n        return this.weightedRatioAdjustment(\n            growHeight,\n            variance,\n            growHeightRatioWeight,\n            function(val, adjustment) {\n                return val + adjustment;\n            }\n        );\n    },\n    drip: function(minLength, maxLength, chance) {\n        minLength = arg(minLength, this.max() * 0.25);\n        maxLength = arg(maxLength, this.max() * 0.75);\n        chance    = arg(chance, 0.45);\n\n        return this.mapEach(function(val) {\n            if (random() < chance) {\n                var newVal = val + random() * (maxLength - minLength) + minLength;\n                return newVal;\n            }\n            return val;\n        });\n    },\n    dripByHeight: function(frequency, percentVariance, frequencyHeightRatioWeight, percentVarianceHeightRatioWeight) {\n        percentVariance                  = arg(percentVariance, 1);\n        frequency                        = arg(frequency, 0.45);\n        frequencyHeightRatioWeight       = arg(frequencyHeightRatioWeight, 1);\n        percentVarianceHeightRatioWeight = arg(percentVarianceHeightRatioWeight, 1);\n\n        return this.mapEach(function(val) {\n            var heightRatio    = val / this.max();\n            var frequencyTotal = 1 + frequencyHeightRatioWeight;\n            var finalChance    = (frequency + heightRatio * frequencyHeightRatioWeight) / frequencyTotal;\n\n            if (random() < finalChance) {\n                var varianceTotal = 1 + percentVarianceHeightRatioWeight,\n                    finalVariance = (percentVariance + heightRatio * percentVarianceHeightRatioWeight) / varianceTotal;\n\n                var newVal = val + random() * (this.max() * finalVariance);\n                return newVal;\n            }\n            return val;\n        });\n    },\n    distort: function(variance) {\n        variance = arg(variance, 0.2 * this.max());\n\n        return this.mapEach(function(val) {\n            return val + (random() * variance) - variance * 0.5;\n        });\n    },\n    adjustRandomSpacedPositions: function(minSpacing, maxSpacing, func) {\n        var indexes = randomSpacedIndexes(this.data.length, minSpacing, maxSpacing);\n        indexes.forEach(function(i) {\n            this.data[i] = func(this.data[i], i, this.data);\n        }, this);\n    },\n    adjustEvery: function(interval, func) {\n        return this.mapEach(function(val, i, arr) {\n            if (i % interval === 0) {\n                return func(val, i, arr);\n            } else {\n                return val;\n            }\n        });\n    },\n    cluster: function(range, weight) {\n        range  = arg(range, 1);\n        weight = arg(weight, 1);\n\n        return this.mapEach(function(val, i, data) {\n\n            var minR = i - range;\n            var maxR = i + range + 1;\n\n            var minI = Math.max(minR, 0);\n            var maxI = Math.min(maxR, data.length);\n\n            var nodes = data.slice(minI, maxI);\n\n            var min = (Math.min.apply(null, nodes) + val * weight) / (1 + weight);\n            var max = (Math.max.apply(null, nodes) + val * weight) / (1 + weight);\n\n            return randomRange(min, max);\n        });\n    }\n};\nmodule.exports = methods;",
    "'use strict';\n\nfunction draw(settings) {\n    var defaults = {\n        heightmap:   null,\n        ctx:         null,\n        x:           0,\n        y:           0,\n        direction:   'up',\n        scale:       1,\n        columnWidth: 1,\n        color:       'rgb(50,100,150)',\n        debug:       false,\n    };\n\n    var s = Object.assign(defaults, settings)\n\n    var heightmap   = s.heightmap;\n    var ctx         = s.ctx;\n    var rx          = s.x;\n    var ry          = s.y;\n    var direction   = s.direction;\n    var scale       = s.scale;\n    var columnWidth = s.columnWidth;\n    var color       = s.color;\n    var debug       = s.debug;\n\n    var data = heightmap.data,\n        len  = data.length,\n        height,\n        i,\n        x,\n        y,\n        w,\n        h;\n\n    for (i = 0; i < len; i++) {\n\n        height        = Math.round(data[i]);\n        ctx.fillStyle = color;\n        if (direction === 'up') {\n            x = rx + i * columnWidth;\n            y = ry - height;\n            w = columnWidth;\n            h = height;\n        } else if (direction === 'left') {\n            x = rx - height;\n            y = ry + i * columnWidth;\n            w = height;\n            h = columnWidth;\n        } else if (direction === 'right') {\n            x = rx;\n            y = ry + i * columnWidth;\n            w = height;\n            h = columnWidth;\n        } else if (direction === 'down') {\n            x = rx + i * columnWidth;\n            y = ry;\n            w = columnWidth;\n            h = height;\n        }\n        ctx.fillRect(\n            x * scale,\n            y * scale,\n            w * scale,\n            h * scale\n        );\n\n        if (\n            debug &&\n            heightmap.debugData &&\n            heightmap.debugData.generateHill\n        ) {\n            var debugData = heightmap.debugData.generateHill;\n\n            var absoluteMin = debugData[i].absoluteMin;\n            var absoluteMax = debugData[i].absoluteMax;\n            var adjustedMin = debugData[i].adjustedMin;\n            var adjustedMax = debugData[i].adjustedMax;\n\n            var debugAbsoluteMinColor = 'red';\n            var debugAbsoluteMaxColor = 'red';\n            var debugAdjustedMinColor = 'orange';\n            var debugAdjustedMaxColor = 'orange';\n\n            var dx = x;\n            var dy = y;\n\n            if (direction === 'up') {\n                dy = ry;\n\n            } else if (direction === 'left') {\n                dx = rx;\n            } else if (direction === 'right') {\n                dx = rx;\n\n            } else if (direction === 'down') {\n                dy = ry;\n            }\n\n            debugDraw(heightmap, ctx, dx, dy, direction, scale, absoluteMin, debugAbsoluteMinColor);\n            debugDraw(heightmap, ctx, dx, dy, direction, scale, absoluteMax, debugAbsoluteMaxColor);\n            debugDraw(heightmap, ctx, dx, dy, direction, scale, adjustedMin, debugAdjustedMinColor);\n            debugDraw(heightmap, ctx, dx, dy, direction, scale, adjustedMax, debugAdjustedMaxColor);\n        }\n    }\n    return this;\n}\n\nfunction debugDraw(heightmap, ctx, x, y, direction, scale, val, color) {\n\n    var dx = x,\n        dy = y;\n\n    if (direction === 'up') {\n        dy = y - val;\n    } else if (direction === 'left') {\n        dx = x + heightmap.max() - val;\n\n    } else if (direction === 'right') {\n        dx = x + val;\n\n    } else if (direction === 'down') {\n        dy = y + val;\n    }\n\n    ctx.globalAlpha = 1;\n    ctx.fillStyle   = color;\n    ctx.fillRect(\n        dx * scale,\n        dy * scale,\n        1 * scale,\n        1 * scale\n    );\n}\n\nmodule.exports = draw;",
    "'use strict';\n\nvar arg = require('./util').arg;\n\nvar rng = Math.random;\n\nvar float = function() {\n    return rng();\n};\n\nvar range = function(min, max) {\n    return Math.floor(rng() * (max - min + 1)) + min;\n};\n\nvar spacedIndexes = function(length, minSpacing, maxSpacing, includeFirstAndLast) {\n    minSpacing = arg(minSpacing, length * 0.1);\n    maxSpacing = arg(maxSpacing, length * 0.3);\n    includeFirstAndLast = arg(includeFirstAndLast, true);\n\n    minSpacing = Math.max(1, minSpacing);\n    maxSpacing = Math.max(1, maxSpacing);\n\n    var indexes = [];\n\n    var next = range(minSpacing, maxSpacing);\n\n    for (var i = 0; i < length; i++) {\n        if (i == next) {\n            indexes.push(i);\n            next = i + range(minSpacing, maxSpacing);\n        }\n    }\n\n    if(includeFirstAndLast){\n        indexes = [0].concat(indexes, [length-1]);\n    }\n\n    return indexes;\n};\n\nvar methods = {\n    set: function(newRng) {\n        rng = newRng;\n    },\n    float:         float,\n    range:         range,\n    spacedIndexes: spacedIndexes,\n};\n\nmodule.exports = methods;\n",
    "'use strict';\n\nvar arg = function(val, defaultVal) {\n    return val !== undefined ? val : defaultVal;\n};\n\nmodule.exports = {\n    arg: arg,\n\n    makeArray: function(length, value) {\n        value = arg(value, 0);\n        var a = [];\n\n        for (var i = 0; i < length; i++) {\n            a[i] = value;\n        }\n        return a;\n    },\n\n};"
  ]
}