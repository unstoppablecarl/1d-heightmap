{
  "version": 3,
  "sources": [
    "node_modules/browser-pack/_prelude.js",
    "src/1d-heightmap.js",
    "src/generators.js",
    "src/index.js",
    "src/methods/compositions.js",
    "src/methods/getters.js",
    "src/methods/init.js",
    "src/methods/iterators.js",
    "src/methods/rng.js",
    "src/methods/transformations.js",
    "src/renderer.js",
    "src/util.js"
  ],
  "names": [],
  "mappings": "AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/RA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "file": "generated.js",
  "sourceRoot": "",
  "sourcesContent": [
    "(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})",
    "'use strict';\n\nvar factory = function OneDHeightmap(settings) {\n    return Object.create(factory.methods).init(settings);\n};\n\nfactory.defaults = {\n    data:      null,\n    length:    100,\n    minHeight: 1,\n    maxHeight: 20,\n};\n\nfactory.methods = Object.assign(\n    {\n        factory: factory\n    },\n    require('./methods/compositions'),\n    require('./methods/getters'),\n    require('./methods/init'),\n    require('./methods/iterators'),\n    require('./methods/rng'),\n    require('./methods/transformations')\n);\n\nmodule.exports = factory;",
    "'use strict';\n\nvar arg           = require('./util').arg;\nvar oneDHeightmapFactory = require('./1d-heightmap');\n\nvar generators = {\n    /**\n     * Create 1dHeightmap object with random data.\n     * @method random\n     * @param {Object} [settings] - Settings object.\n     * @param {Number} [settings.length] - Length of height map.\n     * @param {Array}  [settings.data] - Length of height map. If set, settings.length is ignored.\n     * @param {Number} [settings.minHeight] - Min Height of height map.\n     * @param {Number} [settings.maxHeight] - Max Height of height map.\n     * @param {Number} [settings.startHeight] - Height of first value.\n     * @param {Number} [settings.endHeight] - Height of last value.\n     * @return {Object} Initialized 1dHeightmap object.\n     */\n    random: function(settings) {\n\n        var hm = oneDHeightmapFactory(settings);\n\n        var defaults = {\n            startHeight: undefined,\n            endHeight:   undefined,\n        };\n\n        var s = Object.assign({}, defaults, settings);\n\n        hm.mapEach(function(val, i) {\n            return hm.rngRange(hm.minHeight, hm.maxHeight);\n        });\n\n        if (s.startHeight) {\n            hm.data[0] = s.startHeight;\n        }\n        if (s.endHeight) {\n            hm.data[hm.data.length - 1] = s.endHeight;\n        }\n        return hm;\n    },\n\n    /**\n    * Create 1dHeightmap object with random data.\n    * @method random\n    * @param {Object} [settings] - Settings object.\n    * @param {Number} [settings.length] - Length of height map.\n    * @param {Array}  [settings.data] - Length of height map. If set, settings.length is ignored.\n    * @param {Number} [settings.minHeight] - Min Height of height map.\n    * @param {Number} [settings.maxHeight] - Max Height of height map.\n    * @param {Number} [settings.startHeight] - Height of first value.\n    * @param {Number} [settings.endHeight] - Height of last value.\n    * @param {Number} [settings.minSpacing] - Min distance between key positions initially created.\n    * @param {Number} [settings.maxSpacing] - Max distance between key positions initially created.\n    * @param {Function} [settings.interpolateFunc] - Function to interpolate key position data.\n    * @return {Object} Initialized 1dHeightmap object.\n    */\n    perlin: function(settings) {\n\n        var hm = oneDHeightmapFactory(settings);\n\n        var defaults = {\n            startHeight: null,\n            endHeight:   null,\n\n            minSpacing:      undefined,\n            maxSpacing:      undefined,\n            interpolateFunc: null,\n        };\n\n        var s = Object.assign({}, defaults, settings);\n\n        var startHeight     = s.startHeight;\n        var endHeight       = s.endHeight;\n        var minSpacing      = arg(s.minSpacing, hm.data.length * 0.1);\n        var maxSpacing      = arg(s.maxSpacing, hm.data.length * 0.1);\n        var interpolateFunc = s.interpolateFunc;\n\n        var minHeight = hm.minHeight;\n        var maxHeight = hm.maxHeight;\n\n        var keyIndexes = hm.getRandomSpacedPositions(minSpacing, maxSpacing, true, true);\n        var keyIndexesWithValues = keyIndexes.map(function(index) {\n            return {\n                index: index,\n                value: hm.rngRange(minHeight, maxHeight)\n            };\n        });\n\n        if (startHeight) {\n            keyIndexesWithValues[0] = {\n                index: 0,\n                value: startHeight,\n            };\n        }\n        if (endHeight) {\n            keyIndexesWithValues[keyIndexesWithValues.length - 1] = {\n                index: hm.data.length - 1,\n                value: endHeight\n            };\n        }\n        var results = [];\n        keyIndexesWithValues.forEach(function(item, i) {\n\n            results.push(item.value);\n\n            if (i === keyIndexesWithValues.length - 1) {\n                return;\n            }\n\n            var nextItem        = keyIndexesWithValues[i + 1];\n            var curerntKeyIndex = item.index;\n            var nextKeyIndex    = nextItem.index;\n            var wavelength      = nextKeyIndex - curerntKeyIndex - 1;\n            var a               = item.value;\n            var b               = nextItem.value;\n\n            for (var j = 0; j < wavelength; j++) {\n                var x               = j / wavelength;\n                var interpolatedVal = interpolateFunc(a, b, x);\n                results.push(interpolatedVal);\n            }\n        });\n\n        hm.data = results;\n        return hm;\n    },\n\n    rough: function(settings) {\n        var hm = oneDHeightmapFactory(settings);\n\n        var defaults = {\n            // height that the height map will start at\n            startHeight: 1,\n            // height that the map will end at\n            endHeight: 1,\n\n            variance:          3,\n            edgeDeflectMargin: 0.25,\n            deviationChance:   0.6,\n            // distance at which the height starts tapering to the endHeight\n            endTaperMargin: undefined,\n\n            // distance at which the height starts tapering to the startHeight\n            startTaperMargin: undefined,\n\n            debug: false,\n        };\n\n        var s = Object.assign({}, defaults, settings);\n\n        var debug            = s.debug,\n            startHeight      = arg(s.startHeight, hm.minHeight),\n            startTaperMargin = arg(s.startTaperMargin, hm.maxHeight * 0.25),\n            startTaperHeight,\n            startMinTaperHeight,\n\n            endHeight      = arg(s.endHeight, hm.minHeight),\n            endTaperMargin = arg(s.endTaperMargin, hm.maxHeight * 0.25),\n            endTaperHeight,\n            endMinTaperHeight,\n\n            min               = hm.minHeight,\n            max               = hm.maxHeight,\n            length            = hm.data.length,\n            prevHeight        = startHeight,\n            edgeDeflectMargin = s.edgeDeflectMargin,\n            variance          = s.variance;\n\n        if (debug) {\n            hm.debugData                 = hm.debugData || {};\n            hm.debugData.generateHill    = hm.debugData.generateHill || [];\n            hm.debugData.generateHill[0] = {\n                absoluteMin: startHeight,\n                absoluteMax: startHeight\n            }\n        }\n\n        hm.data[0] = startHeight;\n\n        var startSlope    = ((max - startHeight) / startTaperMargin),\n            startMinSlope = (startHeight / startTaperMargin) * -1,\n            endSlope      = ((max - endHeight) / endTaperMargin),\n            endMinSlope   = (endHeight / endTaperMargin) * -1;\n\n        for (var i = 1; i < length; i++) {\n            var distanceFromEdge = false,\n                startTaperRatio  = false,\n                endTaperRatio    = false,\n                minDeflectRatio  = false,\n                maxDeflectRatio  = false,\n                absoluteMin      = min,\n                absoluteMax      = max;\n\n            if (i < startTaperMargin) {\n                distanceFromEdge = i;\n                startTaperRatio  = (i / startTaperMargin);\n                startTaperHeight = (startSlope * distanceFromEdge) + startHeight;\n                absoluteMax      = startTaperHeight;\n\n                startMinTaperHeight = (startMinSlope * distanceFromEdge) + startHeight;\n                absoluteMin         = startMinTaperHeight;\n            } else if (i > length - endTaperMargin) {\n                distanceFromEdge = length - i;\n                endTaperRatio    = ((length - i) / endTaperMargin);\n                endTaperHeight   = (endSlope * distanceFromEdge) + endHeight;\n                absoluteMax      = endTaperHeight;\n\n                endMinTaperHeight = (endMinSlope * distanceFromEdge) + endHeight;\n                absoluteMin       = endMinTaperHeight;\n            }\n\n            var lowVariance  = prevHeight - variance,\n                highVariance = prevHeight + variance;\n\n            if (lowVariance < absoluteMin) {\n                highVariance += absoluteMin - lowVariance;\n            }\n\n\n            var adjustedMin = Math.max(lowVariance, absoluteMin),\n                adjustedMax = Math.min(highVariance, absoluteMax);\n\n            var height = prevHeight;\n\n            var heightRatio = (height - absoluteMin) / (absoluteMax - absoluteMin);\n\n            // pull away from edges\n            if (heightRatio < edgeDeflectMargin) {\n                minDeflectRatio = 1 - (heightRatio * (1 / edgeDeflectMargin));\n            } else if (heightRatio > 1 - edgeDeflectMargin) {\n                maxDeflectRatio = ((heightRatio - edgeDeflectMargin) * (1 / edgeDeflectMargin));\n            }\n\n            // pull toward start/end height\n            if (\n                startTaperRatio !== false &&\n                height > absoluteMax &&\n                hm.rng() < startTaperRatio - 0.5\n            ) {\n                height = absoluteMax;\n            } else if (\n                endTaperRatio !== false &&\n                height > absoluteMax &&\n                hm.rng() < endTaperRatio - 0.5\n            ) {\n                height = absoluteMax;\n            }\n\n            // pull away from absoluteMin, percentOfMargin = (heightRatio * (1 /edgeMargin))\n            else if (\n                minDeflectRatio !== false &&\n                hm.rng() < minDeflectRatio\n            ) {\n                height += variance;\n            } else if (\n                maxDeflectRatio !== false &&\n                hm.rng() < maxDeflectRatio\n            ) {\n                height -= variance;\n            }\n            // random deviation\n            else if (hm.rng() < s.deviationChance) {\n                height = hm.rng() * (adjustedMax - adjustedMin) + adjustedMin;\n            }\n\n            hm.data[i] = height;\n\n            if (debug) {\n                hm.debugData.generateHill[i] = {\n                    adjustedMin: adjustedMin,\n                    adjustedMax: adjustedMax,\n                    absoluteMin: absoluteMin,\n                    absoluteMax: absoluteMax\n                };\n            }\n\n            prevHeight = hm.data[i];\n        }\n        if (s.endHeight) {\n            hm.data[hm.data.length - 1] = s.endHeight;\n        }\n\n        return hm;\n    },\n};\n\nmodule.exports = generators;",
    "'use strict';\n\nvar api = {\n    create: require('./1d-heightmap'),\n    generate: require('./generators'),\n    draw: require('./renderer'),\n};\n\nmodule.exports = api;",
    "'use strict';\nvar methods = {\n\n    /**\n     * merge 2 height maps taking the lowest value per coord\n     * @method mergeMin\n     * @param {1dHeightMap} heightmap\n     * @return {1dHeightMap}\n     */\n    mergeMin: function(heightmap) {\n        return this.merge(heightmap, function(a, b) {\n            return Math.min(a, b);\n        });\n    },\n\n    /**\n     * merge 2 height maps taking the highest value per coord\n     * @method mergeMax\n     * @param {1dHeightMap} heightmap\n     * @return {1dHeightMap}\n     */\n    mergeMax: function(heightmap) {\n        return this.merge(heightmap, function(a, b) {\n            return Math.max(a, b);\n        });\n    },\n    mergeAdd: function(heightmap) {\n        return this.merge(heightmap, function(a, b) {\n            return a + b;\n        });\n    },\n    mergeSubtract: function(heightmap) {\n        return this.merge(heightmap, function(a, b) {\n            return a - b;\n        });\n    },\n    mergeMultiply: function(heightmap) {\n        return this.merge(heightmap, function(a, b) {\n            return a * b;\n        });\n    },\n    mergeDivide: function(heightmap) {\n        return this.merge(heightmap, function(a, b) {\n            return a / b;\n        });\n    },\n\n    mergeToScale: function(heightmap) {\n        return this.merge(heightmap, function(a, b) {\n            var heightRatio = a / this.maxHeight;\n            return heightRatio * b;\n        });\n    },\n};\nmodule.exports = methods;",
    "'use strict';\nvar arg = require('../util').arg;\n\nvar methods = {\n\n    /** getters */\n    getMin: function() {\n        return Math.min.apply(null, this.data);\n    },\n    getMax: function() {\n        return Math.max.apply(null, this.data);\n    },\n    getRange: function() {\n        return this.getMax() - this.getMin();\n    },\n    getMaxRange: function() {\n        return this.maxHeight - this.minHeight;\n    },\n    getRandomSpacedPositions: function(minSpacing, maxSpacing, includeFirst, includeLast) {\n        minSpacing   = arg(minSpacing, this.data.length * 0.1);\n        maxSpacing   = arg(maxSpacing, this.data.length * 0.3);\n        includeFirst = arg(includeFirst, false);\n        includeLast  = arg(includeLast, false);\n\n        minSpacing = Math.max(1, minSpacing);\n        maxSpacing = Math.max(1, maxSpacing);\n\n        var positions = [];\n\n        if (includeFirst) {\n            positions.push(0);\n        }\n        var next = this.rngRange(minSpacing, maxSpacing);\n\n        for (var i = 0; i < this.data.length; i++) {\n            if (i == next) {\n                positions.push(i);\n                next = i + this.rngRange(minSpacing, maxSpacing);\n            }\n        }\n        if (includeLast) {\n            positions.push(this.data.length - 1);\n        }\n        return positions;\n    },\n};\nmodule.exports = methods;\n\n",
    "'use strict';\n\nvar methods = {\n    /**\n     * Initialzie 1dHeightmap object.\n     * @method init\n     * @param {Object} [settings] - Settings object.\n     * @param {Number} [settings.length] - Length of height map.\n     * @param {Array}  [settings.data] - Length of height map. If set, settings.length is ignored.\n     * @param {Number} [settings.minHeight] - Min Height of height map.\n     * @param {Number} [settings.maxHeight] - Max Height of height map.\n     * @return {Object} Initialized 1dHeightmap object.\n     */\n    init: function(settings) {\n\n        var s = Object.assign({}, this.factory.defaults, settings);\n\n        this.data = s.data;\n\n        if (!this.data) {\n            this.data = [];\n            for (var i = 0; i < s.length; i++) {\n                this.data[i] = 0;\n            }\n        }\n\n        this.minHeight = s.minHeight;\n        this.maxHeight = s.maxHeight;\n\n        return this;\n    },\n    copy: function(settings) {\n        var srcSettings = {\n            data:      [].concat(this.data),\n            minHeight: this.minHeight,\n            maxHeight: this.maxHeight,\n        };\n\n        settings = Object.assign(srcSettings, settings);\n\n        return this.factory(settings);\n    },\n};\nmodule.exports = methods;\n",
    "'use strict';\n\nvar arg = require('../util').arg;\n\nvar methods = {\n    each: function(func, context) {\n        context = arg(context, this);\n\n        this.data.forEach(func, context);\n        return this;\n    },\n    map: function(func, context) {\n        return this.copy({\n            data: this.data.map(func, context)\n        });\n    },\n    mapEach: function(func, context) {\n        context = arg(context, this);\n\n        this.data = this.data.map(func, context);\n        return this;\n    },\n    merge: function(heightmap, func, maxLength) {\n        maxLength = arg(maxLength, Math.max(this.data.length, heightmap.data.length));\n\n        var target = this,\n            source = heightmap,\n            i;\n        for (i = 0; i < maxLength; i++) {\n            var targetVal = target.data[i];\n            var srcVal    = source.data[i];\n\n            target.data[i] = func(targetVal, srcVal, i, target.data, source.data);\n        }\n        return this;\n    },\n\n};\nmodule.exports = methods;\n",
    "'use strict';\n\nvar methods = {\n    rng:      Math.random,\n    rngRange: function(min, max) {\n        return Math.floor(this.rng() * (max - min + 1)) + min;\n    }\n};\nmodule.exports = methods;\n",
    "'use strict';\nvar arg = require('../util').arg;\n\nvar methods = {\n    add: function(val) {\n        return this.mapEach(function(v) {\n            return v + val;\n        });\n    },\n    subtract: function(val) {\n        return this.mapEach(function(v) {\n            return v - val;\n        });\n    },\n    multiply: function(val) {\n        return this.mapEach(function(v) {\n            return v * val;\n        });\n    },\n    divide: function(val) {\n        return this.mapEach(function(v) {\n            return v / val;\n        });\n    },\n    scale: function(scale) {\n        return this.multiply(scale);\n    },\n    invert: function() {\n        return this.mapEach(function(val) {\n            return this.maxHeight - val;\n        });\n    },\n    reverse: function() {\n        this.data.reverse();\n        return this;\n    },\n    scaleToNewMaxHeight: function(maxHeight) {\n        var ratio = maxHeight / this.getMax();\n        return this.multiply(ratio);\n    },\n    scaleLengthTo: function(newLenght, interpolateFunc) {\n        var data      = this.data;\n        var percent   = (newLenght - 1) / (data.length - 1);\n        var keyPoints = [];\n\n        var prevIndex;\n        data.forEach(function(val, index) {\n\n            var newIndex = Math.ceil(index * percent)\n\n            if (newIndex == prevIndex) {\n                return;\n            }\n            keyPoints.push({\n                index: newIndex,\n                value: val\n            });\n\n            prevIndex = newIndex;\n        });\n\n        var results = [];\n        keyPoints.forEach(function(item, index) {\n\n            results.push(item.value);\n\n            if (index === keyPoints.length - 1) {\n                return;\n            }\n\n            var nextItem     = keyPoints[index + 1];\n            var currentIndex = item.index;\n            var nextIndex    = nextItem.index;\n            var chunk        = nextIndex - currentIndex;\n            var a            = item.value;\n            var b            = nextItem.value;\n\n            for (var i = 0; i < chunk; i++) {\n                var x      = i / chunk;\n                var newVal = interpolateFunc(a, b, x);\n                results.push(newVal);\n            }\n        });\n\n        this.data = results;\n\n        return this;\n    },\n\n    smooth: function(weight) {\n        weight = arg(weight, 1);\n\n        var data = this.data,\n            i,\n            prev = data[0];\n        for (i = 1; i < data.length - 1; i++) {\n            var current = data[i],\n                next    = data[i + 1],\n                total   = 2 + weight;\n            current = current * weight;\n            data[i] = (prev + current + next) / total;\n            prev    = current;\n        }\n        return this;\n    },\n    /** RNG transforms */\n    weightedRatioAdjustment: function(height, ratioWeight, func) {\n        height      = arg(height, this.maxHeight * 0.1);\n        ratioWeight = arg(ratioWeight, 1);\n\n        return this.mapEach(function(height, i, data) {\n            var ratio      = (height / this.maxHeight) * ratioWeight;\n            var percent    = (this.rng() + ratio) / (1 + ratioWeight);\n            var adjustment = (percent * height);\n            return func(height, adjustment);\n        });\n    },\n    shrink: function(shrinkHeight, shrinkHeightRatioWeight) {\n        return this.weightedRatioAdjustment(\n            shrinkHeight,\n            shrinkHeightRatioWeight,\n            function(val, adjustment) {\n                return val - adjustment;\n            }\n        );\n    },\n    grow: function(growHeight, growHeightRatioWeight) {\n        return this.weightedRatioAdjustment(\n            growHeight,\n            growHeightRatioWeight,\n            function(val, adjustment) {\n                return val + adjustment;\n            }\n        );\n    },\n    drip: function(minLength, maxLength, chance) {\n        minLength = arg(minLength, this.maxHeight * 0.25);\n        maxLength = arg(maxLength, this.maxHeight * 0.75);\n        chance    = arg(chance, 0.45);\n\n        return this.mapEach(function(val) {\n            if (this.rng() < chance) {\n                var newVal = val + this.rng() * (maxLength - minLength) + minLength;\n                return Math.min(this.maxHeight, newVal);\n            }\n            return val;\n        });\n    },\n    dripByHeight: function(frequency, percentVariance, frequencyHeightRatioWeight, percentVarianceHeightRatioWeight) {\n        percentVariance                  = arg(percentVariance, 1);\n        frequency                        = arg(frequency, 0.45);\n        frequencyHeightRatioWeight       = arg(frequencyHeightRatioWeight, 1);\n        percentVarianceHeightRatioWeight = arg(percentVarianceHeightRatioWeight, 1);\n\n        return this.mapEach(function(val) {\n            var heightRatio    = val / this.maxHeight;\n            var frequencyTotal = 1 + frequencyHeightRatioWeight;\n            var finalChance    = (frequency + heightRatio * frequencyHeightRatioWeight) / frequencyTotal;\n\n            if (this.rng() < finalChance) {\n                var varianceTotal = 1 + percentVarianceHeightRatioWeight,\n                    finalVariance = (percentVariance + heightRatio * percentVarianceHeightRatioWeight) / varianceTotal;\n\n                var newVal = val + this.rng() * (this.maxHeight * finalVariance);\n                return Math.min(this.maxHeight, newVal);\n            }\n            return val;\n        });\n    },\n    distort: function(variance) {\n        variance = arg(variance, 0.2 * this.maxHeight);\n\n        return this.mapEach(function(val) {\n            return val + (this.rng() * variance) - variance * 0.5;\n        });\n    },\n\n    adjustRandomSpacedPositions: function(minSpacing, maxSpacing, func) {\n        var indexes = this.getRandomSpacedPositions(minSpacing, maxSpacing);\n        indexes.forEach(function(i) {\n            this.data[i] = func(this.data[i], i, this.data);\n        }, this);\n    },\n    adjustEvery: function(interval, func) {\n        return this.mapEach(function(val, i, arr) {\n            if (i % interval === 0) {\n                return func(val, i, arr);\n            } else {\n                return val;\n            }\n        });\n    }\n\n};\nmodule.exports = methods;",
    "'use strict';\n\n\nfunction draw(settings) {\n    var defaults = {\n        heightmap:   null,\n        ctx:         null,\n        x:           0,\n        y:           0,\n        direction:   'up',\n        scale:       1,\n        columnWidth: 1,\n        color:       'rgb(50,100,150)',\n        debug:       false,\n    };\n\n    var s = Object.assign(defaults, settings)\n\n    var heightmap   = s.heightmap;\n    var ctx         = s.ctx;\n    var rx          = s.x;\n    var ry          = s.y;\n    var direction   = s.direction;\n    var scale       = s.scale;\n    var columnWidth = s.columnWidth;\n    var color       = s.color;\n    var debug       = s.debug;\n\n    var data = heightmap.data,\n        len  = data.length,\n        height,\n        i,\n        x,\n        y,\n        w,\n        h;\n\n    for (i = 0; i < len; i++) {\n\n        height        = Math.round(data[i]);\n        ctx.fillStyle = color;\n        if (direction === 'up') {\n            x = rx + i * columnWidth;\n            y = ry + heightmap.maxHeight - height;\n            w = columnWidth;\n            h = height;\n        } else if (direction === 'left') {\n            x = rx + heightmap.maxHeight - height;\n            y = ry + i * columnWidth;\n            w = height;\n            h = columnWidth;\n        } else if (direction === 'right') {\n            x = rx;\n            y = ry + i * columnWidth;\n            w = height;\n            h = columnWidth;\n        } else if (direction === 'down') {\n            x = rx + i * columnWidth;\n            y = ry;\n            w = columnWidth;\n            h = height;\n        }\n        ctx.fillRect(\n            x * scale,\n            y * scale,\n            w * scale,\n            h * scale\n        );\n\n        if (\n            debug &&\n            heightmap.debugData &&\n            heightmap.debugData.generateHill\n        ) {\n            var debugData = heightmap.debugData.generateHill;\n\n            var absoluteMin = debugData[i].absoluteMin;\n            var absoluteMax = debugData[i].absoluteMax;\n            var adjustedMin = debugData[i].adjustedMin;\n            var adjustedMax = debugData[i].adjustedMax;\n\n            var debugAbsoluteMinColor = 'red';\n            var debugAbsoluteMaxColor = 'red';\n            var debugAdjustedMinColor = 'orange';\n            var debugAdjustedMaxColor = 'orange';\n\n            var dx = x;\n            var dy = y;\n\n            if (direction === 'up') {\n                dy = ry;\n\n            } else if (direction === 'left') {\n                dx = rx;\n            } else if (direction === 'right') {\n                dx = rx;\n\n            } else if (direction === 'down') {\n                dy = ry;\n            }\n\n            debugDraw(heightmap, ctx, dx, dy, direction, scale, absoluteMin, debugAbsoluteMinColor);\n            debugDraw(heightmap, ctx, dx, dy, direction, scale, absoluteMax, debugAbsoluteMaxColor);\n            debugDraw(heightmap, ctx, dx, dy, direction, scale, adjustedMin, debugAdjustedMinColor);\n            debugDraw(heightmap, ctx, dx, dy, direction, scale, adjustedMax, debugAdjustedMaxColor);\n        }\n    }\n    return this;\n}\n\nfunction debugDraw(heightmap, ctx, x, y, direction, scale, val, color) {\n\n    var dx = x,\n        dy = y;\n\n    if (direction === 'up') {\n        dy = y + heightmap.maxHeight - val;\n\n    } else if (direction === 'left') {\n        dx = x + heightmap.maxHeight - val;\n\n    } else if (direction === 'right') {\n        dx = x + val;\n\n    } else if (direction === 'down') {\n        dy = y + val;\n    }\n\n    ctx.globalAlpha = 1;\n    ctx.fillStyle   = color;\n    ctx.fillRect(\n        dx * scale,\n        dy * scale,\n        1 * scale,\n        1 * scale\n    );\n}\n\nmodule.exports = draw;",
    "'use strict';\n\nvar arg = function(val, defaultVal) {\n    return val !== undefined ? val : defaultVal;\n};\n\nmodule.exports = {\n    arg: arg,\n};"
  ]
}